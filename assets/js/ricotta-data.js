const projectFiles = {
  "brain.py": "import time\nimport traceback\nimport pigpio\nimport pickle\nimport threading\nimport queue\nfrom DriveSystem import DriveSystem\nfrom Sense import LineSensor\nfrom street_behaviors import Behaviors\nfrom AngleSensor import AngleSensor\nfrom MapBuilding import Map, STATUS, prompt_and_load_map\nfrom proximitysensor import ProximitySensor\n\ndef align_to_road(behaviors, map):\n    print(\"Attempting initial alignment to road...\")\n    has_street = False  # Initialize has_street\n    while True:\n        L, M, R = behaviors.sensor.read()\n        if (L, M, R) == (0, 0, 0):\n            print(\"Off-road \u2014 performing U-turn.\")\n            behaviors.turning_behavior(\"left\")\n            result = behaviors.follow_line()\n            if result == \"intersection\":\n                print(\"Back at intersection.\")\n                has_street = behaviors.pull_forward()\n                inter = map.getintersection(map.x, map.y)\n                if has_street:\n                    map.setstreet(map.x, map.y, map.heading, STATUS.UNEXPLORED)\n                else:\n                    map.setstreet(map.x, map.y, map.heading, STATUS.NONEXISTENT)\n                    \n\n               \n\n                \n        else:\n            print(\"On-road \u2014 following line forward.\")\n            result = behaviors.follow_line()\n            if result == \"intersection\":\n                print(\"Reached first intersection.\")\n                has_street = behaviors.pull_forward()\n                inter = map.getintersection(map.x, map.y)\n                if has_street:\n                    map.setstreet(map.x, map.y, map.heading, STATUS.UNEXPLORED)\n                else:\n                    map.setstreet(map.x, map.y, map.heading, STATUS.NONEXISTENT)\n\n                \n            elif result == \"end\":\n                print(\"Dead end detected - executing U-turn\")\n                street_in_front = map.markdeadend(behaviors)\n                if street_in_front:\n                    inter = map.getintersection(map.x, map.y)\n                    x, y, h = map.pose()\n                    map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                    for delta in [-1, 1, -3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                else:\n                    map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                    for delta in [-3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n\n                break\n\n        inter = map.getintersection(map.x, map.y)\n        x, y, h = map.pose()\n        if has_street:\n            for delta in [-1, 1, -3, 3]:\n                diag_heading = (h + delta) % 8\n                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            map.setstreet(x,y,h,STATUS.UNEXPLORED)\n        else:\n            for delta in [-3, 3]:\n                diag_heading = (h + delta) % 8\n                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n\n        break\n\nif __name__ == \"__main__\":\n    io = pigpio.pi()\n    if not io.connected:\n        print(\"Could not connect to pigpio daemon.\")\n        exit()\n\n    try:\n        drive = DriveSystem(io)\n        sensor = LineSensor(io)\n        anglesensor = AngleSensor(io)\n        proximity_sensor = ProximitySensor(io)\n        behaviors = Behaviors(io, drive, sensor, anglesensor)\n\n        choice = input(\"Start with blank map or load from file? (blank/load): \").strip().lower()\n        map = prompt_and_load_map() if choice == \"load\" else Map()\n        choice_is_load = False\n        if choice == \"load\":\n            choice_is_load = True\n\n        print(\"Simple Brain started.\")\n        last_pose = None\n        if not choice_is_load:\n            align_to_road(behaviors, map)\n        \n\n        while True:\n            map.showwithrobot()\n            mode = input(\"Enter command (straight, left, right, goto, save, load, auto, quit): \").strip().lower()\n\n            if mode == \"quit\":\n                break\n\n            if mode in (\"left\", \"right\"):\n                turn_amt, actual_angle = behaviors.turning_behavior(mode)\n                map.markturn(turn_amt, actual_angle)\n                print(f\"The list of possible angles is {map.possible_angles(map.heading,turn_amt)}\")\n\n            elif mode == \"straight\":\n                result = behaviors.follow_line()\n                if result == \"intersection\":\n                    has_street = behaviors.pull_forward()\n                    map.update_connection()\n                    x, y, h = map.pose()\n                    inter = map.intersections.get((x, y))\n                    if has_street:\n                        # Only set to UNEXPLORED if it was UNKNOWN\n                        if inter.streets[h] == STATUS.UNKNOWN:\n                            map.setstreet(x,y,h,STATUS.UNEXPLORED)\n                        # Only mark diagonals as NONEXISTENT\n                        for delta in [-1, 1,3,-3]:\n                            diag_heading = (h + delta) % 8\n                            if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                    else:\n                        # If no street ahead, mark current heading as NONEXISTENT\n                        map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                        # And mark back diagonals as NONEXISTENT\n                        for delta in [-3, 3]:\n                            diag_heading = (h + delta) % 8\n                            if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                elif result == \"end\":\n                    print(\"Dead end detected - executing U-turn\")\n                    original_x, original_y, original_heading = map.markdeadend(behaviors)\n                    # Update robot's position and heading for the U-turn\n                    map.set_pose(original_x, original_y, original_heading)\n\n            elif mode == \"goto\":\n                try:\n                    xgoal = int(input(\"Enter goal x: \"))\n                    ygoal = int(input(\"Enter goal y: \"))\n                    if not map.has_intersection(xgoal, ygoal):\n                        print(f\"Intersection ({xgoal}, {ygoal}) does not exist in map.\")\n                        continue\n                    map.dijkstra(xgoal, ygoal)\n                    print(\"Goal set. Navigating...\")\n                    while map.goal is not None:\n                        map.showwithrobot()\n                        map.step_toward_goal(behaviors)\n                except ValueError:\n                    print(\"Invalid goal input.\")\n\n            elif mode == \"save\":\n                filename = input(\"Enter filename to save (e.g. mymap.pkl): \").strip()\n                with open(filename, 'wb') as file:\n                    pickle.dump(map, file)\n                print(f\"Map saved to {filename}\")\n\n            elif mode == \"load\":\n                map = prompt_and_load_map()\n\n            elif mode == \"auto\":\n                print(\"Autonomous mode: Robot is exploring the map...\")\n                while True:\n                    map.showwithrobot()\n                    x, y, current_heading = map.pose()\n                    print(f\"\\nCurrent Position: ({x}, {y}), Heading: {current_heading}\")\n                    current_intersection = map.intersections.get((x, y))\n\n                    if not current_intersection:\n                        print(\"Error: Robot not at a valid intersection\")\n                        break\n\n                    # Print current intersection state\n                    print(\"\\nCurrent intersection street states:\")\n                    for h in range(8):\n                        status = current_intersection.streets[h]\n                        print(f\"Heading {h}: {status}\")\n\n                    # Step 1: Check for UNKNOWN streets\n                    unknown_headings = [h for h in range(8)\n                                     if current_intersection.streets[h] == STATUS.UNKNOWN]\n                    print(f\"\\nUnknown streets at headings: {unknown_headings}\")\n                    \n                    if unknown_headings:\n                        # Find heading with smallest rotation needed\n                        best_heading = min(unknown_headings, \n                                         key=lambda h: min((h - current_heading) % 8, \n                                                         (current_heading - h) % 8))\n                        print(f\"Best heading: {best_heading}\")\n                        diff = (best_heading - current_heading) % 8\n                        counter_diff = (current_heading - best_heading) % 8\n                        if diff <= counter_diff:\n                            turn_direction = \"left\"\n                        else:\n                            turn_direction = \"right\"\n                        \n                        print(f\"Found unknown street at heading {best_heading}, turning {turn_direction}\")\n                        prev_heading = current_heading\n                        max_turns = 4  # Maximum number of turns to prevent infinite loop\n                        turns_made = 0\n                        \n                        while current_heading != best_heading and turns_made < max_turns:\n                            turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                            map.markturn(turn_amt, actual_angle)\n                            x, y, current_heading = map.pose()\n                            print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                            \n                            # Check if we're making progress\n                            if current_heading == prev_heading:\n                                print(\"Warning: Not making progress in turning, stopping\")\n                                break\n                                \n                            prev_heading = current_heading\n                            turns_made += 1\n                            \n                        if turns_made >= max_turns:\n                            print(\"Warning: Reached maximum number of turns without reaching desired heading\")\n\n                        result = behaviors.follow_line()\n                        if result == \"intersection\":\n                            has_street = behaviors.pull_forward()\n                            map.update_connection()\n                            x, y, h = map.pose()\n                            print(f\"Reached intersection - Position: ({x}, {y}), Heading: {h}\")\n                            print(f\"Street ahead exists: {has_street}\")\n                            inter = map.intersections.get((x, y))\n                            if has_street:\n                                # Mark current street as UNEXPLORED\n                                if inter.streets[h] == STATUS.UNKNOWN:\n                                    map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                                    print(f\"Marked street at heading {h} as UNEXPLORED\")\n                                # Mark diagonals as NONEXISTENT\n                                for delta in [-1, 1, -3, 3]:\n                                    diag_heading = (h + delta) % 8\n                                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                                        print(f\"Marked diagonal street at heading {diag_heading} as NONEXISTENT\")\n                            else:\n                                # If no street ahead, mark current heading as NONEXISTENT\n                                map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                                print(f\"Marked street at heading {h} as NONEXISTENT\")\n                                # Mark back diagonals as NONEXISTENT\n                                for delta in [-3, 3]:\n                                    diag_heading = (h + delta) % 8\n                                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                                        print(f\"Marked back diagonal street at heading {diag_heading} as NONEXISTENT\")\n                        elif result == \"end\":\n                            print(\"Dead end detected - executing U-turn\")\n                            original_x, original_y, original_heading = map.markdeadend(behaviors)\n                            # Update robot's position and heading for the U-turn\n                            map.set_pose(original_x, original_y, original_heading)\n                            inter = map.getintersection(map.x, map.y)\n                            x, y, h = map.pose()\n                            # Mark current street as NONEXISTENT since it's a dead end\n                            map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                            # Mark diagonals as NONEXISTENT\n                            for delta in [-3, 3]:\n                                diag_heading = (h + delta) % 8\n                                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                        continue\n\n                    # Step 2: Check for UNEXPLORED streets\n                    unexplored_headings = [h for h in range(8)\n                                         if current_intersection.streets[h] == STATUS.UNEXPLORED]\n                    print(f\"\\nUnexplored streets at headings: {unexplored_headings}\")\n                    \n                    if unexplored_headings:\n                        # Find heading with smallest rotation needed\n                        best_heading = min(unexplored_headings,\n                                         key=lambda h: min((h - current_heading) % 8,\n                                                         (current_heading - h) % 8))\n                        diff = (best_heading - current_heading) % 8\n                        counter_diff = (current_heading - best_heading) % 8\n                        if diff <= counter_diff:\n                            turn_direction = \"left\"\n                        else:\n                            turn_direction = \"right\"\n                        \n                        print(f\"Found unexplored street at heading {best_heading}, turning {turn_direction}\")\n                        while current_heading != best_heading:\n                            turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                            map.markturn(turn_amt, actual_angle)\n                            x, y, current_heading = map.pose()\n                            print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n\n                        result = behaviors.follow_line()\n                        if result == \"intersection\":\n                            has_street = behaviors.pull_forward()\n                            map.update_connection()\n                            x, y, h = map.pose()\n                            print(f\"Reached intersection - Position: ({x}, {y}), Heading: {h}\")\n                            print(f\"Street ahead exists: {has_street}\")\n                            inter = map.intersections.get((x, y))\n                            if has_street:\n                                # Mark current street as UNEXPLORED\n                                map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                                print(f\"Marked street at heading {h} as UNEXPLORED\")\n                                # Mark diagonals as NONEXISTENT\n                                for delta in [-1, 1, -3, 3]:\n                                    diag_heading = (h + delta) % 8\n                                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                                        print(f\"Marked diagonal street at heading {diag_heading} as NONEXISTENT\")\n                            else:\n                                # If no street ahead, mark current heading as NONEXISTENT\n                                map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                                print(f\"Marked street at heading {h} as NONEXISTENT\")\n                                # Mark back diagonals as NONEXISTENT\n                                for delta in [-3, 3]:\n                                    diag_heading = (h + delta) % 8\n                                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                                        print(f\"Marked back diagonal street at heading {diag_heading} as NONEXISTENT\")\n                        elif result == \"end\":\n                            print(\"Dead end detected - executing U-turn\")\n                            original_x, original_y, original_heading = map.markdeadend(behaviors)\n                            # Update robot's position and heading for the U-turn\n                            map.set_pose(original_x, original_y, original_heading)\n                            inter = map.getintersection(map.x, map.y)\n                            x, y, h = map.pose()\n                            # Mark current street as NONEXISTENT since it's a dead end\n                            map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                            # Mark diagonals as NONEXISTENT\n                            for delta in [-3, 3]:\n                                diag_heading = (h + delta) % 8\n                                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                        continue\n\n                    # Use Dijkstra's to find nearest intersection with unknown/unexplored streets\n                    found_goal = False\n                    min_distance = float('inf')\n                    best_goal = None\n                    \n                    print(\"\\nSearching for nearest intersection with unknown/unexplored streets...\")\n                    # First check all intersections for unknown/unexplored streets\n                    for tx, ty in map.intersections.keys():\n                        inter = map.intersections[(tx, ty)]\n                        unknown_or_unexplored = [h for h in range(8) if inter.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)]\n                        if unknown_or_unexplored:\n                            # manhattan distance\n                            distance = abs(tx - x) + abs(ty - y)\n                            print(f\"Found intersection at ({tx}, {ty}) with unknown/unexplored streets at headings {unknown_or_unexplored}, distance: {distance}\")\n                            if distance < min_distance:\n                                min_distance = distance\n                                best_goal = (tx, ty)\n                    \n                    if best_goal:\n                        tx, ty = best_goal\n                        print(f\"\\nSetting goal to nearest intersection ({tx}, {ty}) with unknown/unexplored streets\")\n                        print(f\"Current position: ({x}, {y}), Distance to goal: {min_distance}\")\n                        map.dijkstra(tx, ty)\n                        found_goal = True\n                        \n                        print(\"Navigating to next unexplored area...\")\n                        while map.goal is not None:\n                            map.showwithrobot()\n                            map.step_toward_goal(behaviors)\n                            x, y, current_heading = map.pose()\n                            print(f\"Moving to goal - Position: ({x}, {y}), Heading: {current_heading}\")\n                    else:\n                        print(\"Exploration complete! No more unknown or unexplored streets.\")\n                        break\n\n                \n            else:\n                print(\"Invalid input. Please enter a valid command.\")\n\n    except KeyboardInterrupt:\n        print(\"KeyboardInterrupt detected. Shutting down.\")\n    except BaseException as ex:\n        print(f\"Ending due to exception: {repr(ex)}\")\n        traceback.print_exc()\n    finally:\n        drive.stop()\n        io.stop()\n        print(\"Robot stopped. Brain shutdown :3\")\n",
  "navigation.py": "import time\nfrom MapBuilding import STATUS\nfrom uithread import Shared\nimport math\n\n#  for start up\ndef align_to_road(behaviors, map, shared):\n    print(\"Attempting initial alignment to road...\")\n\n    x = int(input(\"Enter global x coordinate for current intersection: \"))\n    y = int(input(\"Enter global y coordinate for current intersection: \"))\n    \n    # Set the initial position in the map\n    map.set_pose(x, y, 0)  # Start with heading 0, will be updated later\n\n    has_street = False\n    while True:\n        desired_heading = 0\n        L, M, R = behaviors.sensor.read()\n        if (L, M, R) == (0, 0, 0):\n            print(\"Off-road \u2014 performing U-turn.\")\n            behaviors.turning_behavior(\"left\")\n            result = behaviors.follow_line()\n            if result == \"intersection\":\n                print(\"Back at intersection.\")\n                has_street = behaviors.pull_forward()\n                inter = map.getintersection(map.x, map.y)\n                \n                print(\"\\nEnter desired heading (0-7):\")\n                while True:\n                    try:\n                        desired_heading = int(input(\"Heading: \"))\n                        if 0 <= desired_heading <= 7:\n                            break\n                        else:\n                            print(\"Please enter a number between 0 and 7\")\n                    except ValueError:\n                        print(\"Please enter a valid number\")\n            \n                # Set the heading in the map without turning the robot\n                # Set the pose in the map and shared data\n                map.set_pose(x, y, desired_heading)\n                with shared.lock:\n                    shared.robotx = x\n                    shared.roboty = y\n                    shared.robotheading = desired_heading\n                print(f\"Map heading set to: {desired_heading}\")\n                \n                if has_street:\n                    map.setstreet(map.x, map.y, desired_heading, STATUS.UNEXPLORED)\n                    for delta in [-1, 1, -3, 3]:\n                        diag = (desired_heading + delta) % 8\n                        if inter.streets[diag] == STATUS.UNKNOWN:\n                            map.setstreet(map.x, map.y, diag, STATUS.NONEXISTENT)\n                else:\n                    for delta in [-3, 3]:\n                        map.setstreet(map.x, map.y, desired_heading, STATUS.NONEXISTENT)\n                        diag = (desired_heading + delta) % 8\n                        if inter.streets[diag] == STATUS.UNKNOWN:\n                            map.setstreet(map.x, map.y, diag, STATUS.NONEXISTENT)\n                    map.setstreet(map.x, map.y, desired_heading, STATUS.NONEXISTENT)\n                    \n                break\n        else:\n            print(\"On-road \u2014 following line forward.\")\n            # Check for blockage before moving\n            blocked = behaviors.check_blockage(desired_heading)\n            if blocked:\n                print(\"Street ahead is blocked, marking as blocked\")\n                map.set_blocked(map.x, map.y, map.heading, True)\n                # Get current intersection\n                inter = map.getintersection(map.x, map.y)\n                # Find and align to a valid unblocked street\n                valid_headings = [h for h in range(8) \n                                if inter.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED, STATUS.CONNECTED)\n                                and not map.is_blocked(map.x, map.y, h)]\n                if valid_headings:\n                    best_heading = min(valid_headings,\n                                    key=lambda h: min((h - map.heading) % 8,\n                                                    (map.heading - h) % 8))\n                    print(f\"Aligning to valid street at heading {best_heading}\")\n                    diff = (best_heading - map.heading) % 8\n                    counter_diff = (map.heading - best_heading) % 8\n                    turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                    \n                    while map.heading != best_heading:\n                        turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                        map.markturn(turn_amt, actual_angle)\n                        print(f\"After alignment turn - Position: ({map.x}, {map.y}), Heading: {map.heading}\")\n                else:\n                    print(\"No valid unblocked streets available\")\n                    return\n                continue\n\n            result = behaviors.follow_line()\n            if result == \"intersection\":\n                print(\"Reached first intersection.\")\n                has_street = behaviors.pull_forward()\n                inter = map.getintersection(map.x, map.y)\n                \n                print(\"\\nEnter desired heading (0-7):\")\n                while True:\n                    try:\n                        desired_heading = int(input(\"Heading: \"))\n                        if 0 <= desired_heading <= 7:\n                            break\n                        else:\n                            print(\"Please enter a number between 0 and 7\")\n                    except ValueError:\n                        print(\"Please enter a valid number\")\n            \n                # Set the heading in the map without turning the robot\n                map.set_pose(map.x, map.y, desired_heading)\n                print(f\"Map heading set to: {desired_heading}\")\n                \n                if has_street:\n                    map.setstreet(map.x, map.y, desired_heading, STATUS.UNEXPLORED)\n                    for delta in [-1, 1, -3, 3]:\n                        diag = (desired_heading + delta) % 8\n                        if inter.streets[diag] == STATUS.UNKNOWN:\n                            map.setstreet(map.x, map.y, diag, STATUS.NONEXISTENT)\n                else:\n                    map.setstreet(map.x, map.y, desired_heading, STATUS.NONEXISTENT)\n                    for delta in [-3, 3]:\n                        diag = (desired_heading + delta) % 8\n                        if inter.streets[diag] == STATUS.UNKNOWN:\n                            map.setstreet(map.x, map.y, diag, STATUS.NONEXISTENT)\n                break\n            elif result == \"end\":\n                print(\"Dead end detected - executing U-turn\")\n                original_x, original_y, original_heading = map.markdeadend()\n                # Calculate new heading after U-turn\n                time.sleep(0.1)  # Add delay before turning\n                handle_deadend(map, behaviors, original_x, original_y, original_heading)\n                x, y, current_heading = map.pose()\n                print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n        break\n\n\ndef step_toward_goal(map, behaviors):\n    x, y, h = map.pose()\n    inter = map.getintersection(x, y)\n\n    # If the robot is at the goal, clear the goal and return\n    if (x, y) == map.goal:\n        print(\"Goal reached!\")\n        map.cleargoal()\n        return\n\n    # If there are no known paths to goal, replan\n    direction = inter.direction\n    if direction is None:\n        print(\"No known path to goal, replanning...\")\n        map.dijkstra(map.goal[0], map.goal[1])\n        inter = map.getintersection(x, y)\n        direction = inter.direction\n        if direction is None:\n            print(\"No possible route to goal - goal is unreachable!\")\n            map.clear_blockages()  # Clear blockages so robot can recover\n            print(\"Blockages cleared, retrying path to goal...\")\n            map.dijkstra(map.goal[0], map.goal[1])\n            step_toward_goal(map, behaviors)\n            return\n\n    # If the robot is facing the goal, move forward\n    if direction != h:\n        # Decide turn direction\n        turn_amt = (direction - h) % 8\n        if turn_amt > 4:\n            turn_amt -= 8\n        turn_dir = \"left\" if turn_amt > 0 else \"right\"\n\n        # Start turning, one step (45) at a time, until at correct heading\n        turns_made = 0\n        max_turns = 4\n        while h != direction and turns_made < max_turns:\n            print(f\"Current heading: {h}, desired: {direction}\")\n\n            # Turn one 45 step\n            step = 1 if turn_dir == \"left\" else -1\n            turn_result = behaviors.turning_behavior(turn_dir)  # should return number of steps taken (\u00b11)\n            turn_amount, actual_angle = turn_result\n            map.markturn(turn_amount, actual_angle)\n            turns_made += 1\n            time.sleep(0.1)\n\n            # Read sensors after turn\n            L, M, R = behaviors.sensor.read()\n            is_on_line = (L, M, R) != (0, 0, 0)\n\n            # Check for a valid street at new heading using sensor AND map\n            inter = map.getintersection(map.x, map.y)\n\n            # Check for blockage after turn\n            blocked = behaviors.check_blockage(h)\n            if blocked:\n                print(\"Blocked street detected! Replanning path...\")\n                # Mark the current street as blocked using current position and heading\n                map.set_blocked(x, y, map.heading, True)\n                # Replan path to goal from current position\n                map.dijkstra(map.goal[0], map.goal[1])\n                # Check if a valid path was found after replanning\n                inter = map.getintersection(x, y)\n                if inter.direction is None:\n                    print(\"No possible route to replan to - goal is unreachable!\")\n                    map.cleargoal()\n                    return\n                # Get new direction after replanning\n                direction = inter.direction\n                # If we need to turn to follow new path\n                if direction != map.heading:\n                    print(f\"Turning to follow new path. Current heading: {map.heading}, New direction: {direction}\")\n                    turn_amt = (direction - map.heading) % 8\n                    if turn_amt > 4:\n                        turn_amt -= 8\n                    turn_dir = \"left\" if turn_amt > 0 else \"right\"\n                    turns_made = 0\n                    max_turns = 4\n                    while map.heading != direction and turns_made < max_turns:\n                        turn_result = behaviors.turning_behavior(turn_dir)\n                        turn_amount, actual_angle = turn_result\n                        map.markturn(turn_amount, actual_angle)\n                        x, y, h = map.pose()\n                        turns_made += 1\n                        time.sleep(0.1)\n                    if turns_made >= max_turns:\n                        print(\"Warning: Reached maximum number of turns without reaching desired heading\")\n                        return\n                return\n\n            print(f\"Sensor sees line: {is_on_line}, map says street at heading {map.heading} is {inter.streets[map.heading].name}\")\n            valid_street = inter.streets[map.heading] not in (STATUS.NONEXISTENT, STATUS.DEADEND)\n\n            if map.heading == direction and is_on_line and valid_street:\n                print(\"Aligned to correct heading with valid street \u2014 done turning.\")\n                break\n            elif is_on_line:\n                print(\"At wrong street. Pausing briefly before continuing turn...\")\n                behaviors.drive.stop()\n                time.sleep(0.3)  # Let robot sit on wrong street before resuming\n\n        if turns_made >= max_turns:\n            print(\"Warning: Reached maximum number of turns without reaching desired heading\")\n            # Force set the heading to prevent further turning\n            map.set_pose(map.x, map.y, direction)\n            return\n        # After turning, update h\n        x, y, h = map.pose()\n\n    # Now, robot is facing the correct direction\n    print(\"Advancing toward goal...\")\n    blocked = behaviors.check_blockage(h)\n    if blocked:\n        print(f\"Blocked street detected at heading {h}! Current position: ({x}, {y})\")\n        # Mark the current street as blocked using current position and heading\n        map.set_blocked(x, y, h, True)\n        print(f\"Marked street at heading {h} as blocked\")\n        # Replan path to goal from current position\n        map.dijkstra(map.goal[0], map.goal[1])\n        # Check if a valid path was found after replanning\n        inter = map.getintersection(x, y)\n        if inter.direction is None:\n            print(\"No possible route to replan to - goal is unreachable!\")\n            map.clear_blockages()  # Clear blockages so robot can recover\n            print(\"Blockages cleared, retrying path to goal...\")\n            map.dijkstra(map.goal[0], map.goal[1])\n            step_toward_goal(map, behaviors)\n            return\n        # Get new direction after replanning\n        direction = inter.direction\n        print(f\"New direction after replanning: {direction}\")\n        # If we need to turn to follow new path\n        if direction != h:\n            print(f\"Turning to follow new path. Current heading: {h}, New direction: {direction}\")\n            turn_amt = (direction - h) % 8\n            if turn_amt > 4:\n                turn_amt -= 8\n            turn_dir = \"left\" if turn_amt > 0 else \"right\"\n            print(f\"Need to turn {turn_amt} steps {turn_dir}\")\n            turns_made = 0\n            max_turns = 4\n            while h != direction and turns_made < max_turns:\n                print(f\"Making turn {turns_made + 1}/{max_turns}\")\n                turn_result = behaviors.turning_behavior(turn_dir)\n                turn_amount, actual_angle = turn_result\n                print(f\"Turn result: amount={turn_amount}, actual_angle={actual_angle}\")\n                map.markturn(turn_amount, actual_angle)\n                x, y, h = map.pose()\n                print(f\"After turn - Position: ({x}, {y}), Heading: {h}\")\n                turns_made += 1\n                time.sleep(0.1)\n            if turns_made >= max_turns:\n                print(\"Warning: Reached maximum number of turns without reaching desired heading\")\n                return\n        return\n\n    # Actually move forward toward the goal\n    result = behaviors.follow_line()\n    if result == \"intersection\":\n        has_street = behaviors.pull_forward()\n        if has_street:\n            map.setstreet(x, y, h, STATUS.UNEXPLORED)\n            for delta in [-1, 1, 3, -3]:\n                side_heading = (map.heading + delta) % 8\n                if inter.streets[side_heading] == STATUS.UNKNOWN:\n                    inter.streets[side_heading] = STATUS.NONEXISTENT\n        else:\n            map.setstreet(x, y, h, STATUS.NONEXISTENT)\n            for delta in [-3, 3]:\n                side_heading = (map.heading + delta) % 8\n                if inter.streets[side_heading] == STATUS.UNKNOWN:\n                    inter.streets[side_heading] = STATUS.NONEXISTENT\n        map.update_connection()\n        # Replan at each intersection to ensure optimal path\n        map.dijkstra(map.goal[0], map.goal[1])\n    elif result == \"end\":\n        print(\"Dead end detected - executing U-turn\")\n        original_x, original_y, original_heading = map.markdeadend()\n        # Calculate new heading after U-turn\n        time.sleep(0.1)  # Add delay before turning\n        handle_deadend(map, behaviors, original_x, original_y, original_heading)\n        x, y, current_heading = map.pose()\n        print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n\n\ndef handle_deadend(map, behaviors, original_x, original_y, original_heading):\n    \"\"\"Handle dead end by performing U-turn and line following back to intersection.\"\"\"\n    # Perform U-turn\n    print(\"Executing U-turn...\")\n    turn_amt, actual_angle = behaviors.turning_behavior(\"left\")\n    map.calcuturn()  # Update heading in the map by 4 (180 degrees)\n    \n    # Line follow back to intersection\n    print(\"Line following back to intersection...\")\n    result = behaviors.follow_line()\n    if result == \"intersection\":\n        print(\"Back at intersection after U-turn\")\n        has_street = behaviors.pull_forward()\n        # After pulling forward, we should be at the intersection facing away from the dead end\n        x, y, current_heading = map.pose()\n        # Mark the street as dead end now that we're back at the intersection\n        # Note: We mark the street in the opposite direction of our current heading\n        inter = map.getintersection(x, y)\n        deadend_heading = (current_heading + 4) % 8  # Opposite of current heading\n        if inter.streets[deadend_heading] != STATUS.NONEXISTENT:\n            inter.streets[deadend_heading] = STATUS.DEADEND\n            print(f\"Marked street at heading {deadend_heading} as DEADEND\")\n        \n        # Mark the street we came from based on pull_forward result\n        if has_street:\n            if inter.streets[current_heading] == STATUS.UNKNOWN:\n                inter.streets[current_heading] = STATUS.UNEXPLORED\n                print(f\"Marked street at heading {current_heading} as UNEXPLORED\")\n            # Mark diagonals as NONEXISTENT\n            for delta in [-1, 1, -3, 3]:\n                diag_heading = (current_heading + delta) % 8\n                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                    inter.streets[diag_heading] = STATUS.NONEXISTENT\n                    print(f\"Marked diagonal street at heading {diag_heading} as NONEXISTENT\")\n        else:\n            # If no street ahead, mark current heading as NONEXISTENT\n            inter.streets[current_heading] = STATUS.NONEXISTENT\n            print(f\"Marked street at heading {current_heading} as NONEXISTENT\")\n            # Mark back diagonals as NONEXISTENT\n            for delta in [-3, 3]:\n                diag_heading = (current_heading + delta) % 8\n                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                    inter.streets[diag_heading] = STATUS.NONEXISTENT\n                    print(f\"Marked back diagonal street at heading {diag_heading} as NONEXISTENT\")\n        \n        # Debug print: robot's position, heading, and next intersection\n        print(f\"[DEBUG] After dead end handling: Position: ({x}, {y}), Heading: {current_heading}\")\n        # Find next intersection to go to (if any)\n        unexplored = []\n        for (ix, iy), intersection in map.intersections.items():\n            for heading in range(8):\n                if intersection.streets[heading] in (STATUS.UNKNOWN, STATUS.UNEXPLORED):\n                    unexplored.append((ix, iy))\n                    break\n        if unexplored:\n            # Find the closest unexplored intersection\n            next_goal = min(unexplored, key=lambda pos: abs(pos[0] - x) + abs(pos[1] - y))\n            print(f\"[DEBUG] Next intersection to go to: {next_goal}\")\n        else:\n            print(\"[DEBUG] No more unexplored intersections left.\")\n    else:\n        print(\"Warning: Did not reach intersection after U-turn\")\n\ndef autonomous_step(map, behaviors):\n    print(\"Autonomous mode: Robot is exploring the map...\")\n    x, y, current_heading = map.pose()\n    print(f\"\\nCurrent Position: ({x}, {y}), Heading: {current_heading}\")\n    current_intersection = map.intersections.get((x, y))\n\n    if not current_intersection:\n        print(\"Error: Robot not at a valid intersection\")\n        return\n\n    # Print current intersection state\n    print(\"\\nCurrent intersection street states:\")\n    for h in range(8):\n        status = current_intersection.streets[h]\n        blocked = current_intersection.blocked[h] if hasattr(current_intersection, 'blocked') else False\n        print(f\"Heading {h}: {status} {'(BLOCKED)' if blocked else ''}\")\n\n    # Check if we need to update street status for current heading\n    if current_intersection.streets[current_heading] == STATUS.UNKNOWN:\n        # Check if we're on a line (which would indicate a street exists)\n        L, M, R = behaviors.sensor.read()\n        has_street = (L, M, R) != (0, 0, 0)\n        print(f\"Street ahead exists: {has_street}\")\n        \n        if has_street:\n            # Mark current street as UNEXPLORED\n            map.setstreet(x, y, current_heading, STATUS.UNEXPLORED)\n            print(f\"Marked street at heading {current_heading} as UNEXPLORED\")\n            # Mark diagonals as NONEXISTENT\n            for delta in [-1, 1, -3, 3]:\n                diag_heading = (current_heading + delta) % 8\n                if current_intersection.streets[diag_heading] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                    print(f\"Marked diagonal street at heading {diag_heading} as NONEXISTENT\")\n        else:\n            # If no street ahead, mark current heading as NONEXISTENT\n            map.setstreet(x, y, current_heading, STATUS.NONEXISTENT)\n            print(f\"Marked street at heading {current_heading} as NONEXISTENT\")\n            # Mark back diagonals as NONEXISTENT\n            for delta in [-3, 3]:\n                diag_heading = (current_heading + delta) % 8\n                if current_intersection.streets[diag_heading] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                    print(f\"Marked back diagonal street at heading {diag_heading} as NONEXISTENT\")\n\n    # Step 1: Check for UNKNOWN streets (skip blocked)\n    unknown_headings = [h for h in range(8)\n                        if current_intersection.streets[h] == STATUS.UNKNOWN \n                        and not map.is_blocked(x, y, h)]\n    print(f\"\\nUnblocked unknown streets at headings: {unknown_headings}\")\n    \n    if unknown_headings:\n        # Find heading with smallest rotation needed\n        best_heading = min(unknown_headings, \n                            key=lambda h: min((h - current_heading) % 8, \n                                            (current_heading - h) % 8))\n        print(f\"Best heading: {best_heading}\")\n        \n        # Check if best heading is blocked before attempting to turn\n        if map.is_blocked(x, y, best_heading):\n            print(f\"Best heading {best_heading} is blocked, removing from unknown_headings\")\n            unknown_headings.remove(best_heading)\n            if not unknown_headings:\n                print(\"No more unblocked unknown streets to explore\")\n                return\n            # Recalculate best heading\n            best_heading = min(unknown_headings, key=lambda h: min((h - current_heading) % 8, (current_heading - h) % 8))\n            print(f\"New best heading: {best_heading}\")\n        \n        diff = (best_heading - current_heading) % 8\n        counter_diff = (current_heading - best_heading) % 8\n        if diff <= counter_diff:\n            turn_direction = \"left\"\n        else:\n            turn_direction = \"right\"\n        \n        print(f\"Found unknown street at heading {best_heading}, turning {turn_direction}\")\n        prev_heading = current_heading\n        max_turns = 4  # Maximum number of turns to prevent infinite loop\n        turns_made = 0\n        \n        while current_heading != best_heading and turns_made < max_turns:\n            turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n            map.markturn(turn_amt, actual_angle)\n            x, y, current_heading = map.pose()\n            \n            print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            \n            # Check if we're making progress towards the desired heading\n            current_diff = (best_heading - current_heading) % 8\n            prev_diff = (best_heading - prev_heading) % 8\n            if current_diff >= prev_diff:\n                print(\"Warning: Not making progress towards desired heading, stopping\")\n                break\n                \n            prev_heading = current_heading\n            turns_made += 1\n            \n            # Add a small delay between turns to prevent rapid spinning\n            time.sleep(0.1)\n            \n            \n        # Check for blockage before moving forward\n        blocked = behaviors.check_blockage(current_heading)\n        if blocked:\n            print(f\"Street at heading {current_heading} is blocked, marking as blocked\")\n            map.set_blocked(x, y, current_heading, True)\n            # Find next valid heading to explore\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                best_heading = min(valid_headings,\n                                key=lambda h: min((h - current_heading) % 8,\n                                                (current_heading - h) % 8))\n                print(f\"Turning to next valid heading {best_heading}\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                turns_made = 0\n                max_turns = 4\n                while current_heading != best_heading and turns_made < max_turns:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                    turns_made += 1\n                if turns_made >= max_turns:\n                    print(\"Warning: Reached maximum number of turns without reaching desired heading; keeping current heading.\")\n                    return\n            else:\n                print(\"No more valid headings to explore at this intersection\")\n                return\n        else:\n            result = behaviors.follow_line()\n            if result == \"intersection\":\n                has_street = behaviors.pull_forward()\n                map.update_connection()\n                x, y, h = map.pose()\n                print(f\"Reached intersection - Position: ({x}, {y}), Heading: {h}\")\n                print(f\"Street ahead exists: {has_street}\")\n                \n                # Check for blockage at the intersection\n                blocked = behaviors.check_blockage(h)\n                if blocked:\n                    print(f\"Street at heading {h} is blocked, marking as blocked\")\n                    map.set_blocked(x, y, h, True)\n                    # Mark diagonals as NONEXISTENT if they are UNKNOWN\n                    if has_street:\n                        inter = map.getintersection(x, y)\n                        for delta in [-1, 1, -3, 3]:\n                            diag = (h + delta) % 8\n                            if inter.streets[diag] == STATUS.UNKNOWN:\n                                map.setstreet(x, y, diag, STATUS.NONEXISTENT)\n                    else:\n                        inter = map.getintersection(x, y)\n                        for delta in [-3, 3]:\n                            diag = (h + delta) % 8\n                            if inter.streets[diag] == STATUS.UNKNOWN:\n                                map.setstreet(x, y, diag, STATUS.NONEXISTENT)\n                    # Find next valid heading to explore\n                    valid_headings = [h for h in range(8) \n                                    if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                                    and not map.is_blocked(x, y, h)\n                                    and current_intersection.streets[h] != STATUS.DEADEND]\n                    if valid_headings:\n                        best_heading = min(valid_headings,\n                                        key=lambda h: min((h - current_heading) % 8,\n                                                        (current_heading - h) % 8))\n                        print(f\"Turning to next valid heading {best_heading}\")\n                        diff = (best_heading - current_heading) % 8\n                        counter_diff = (current_heading - best_heading) % 8\n                        turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                        \n                        turns_made = 0\n                        max_turns = 4\n                        while current_heading != best_heading and turns_made < max_turns:\n                            turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                            map.markturn(turn_amt, actual_angle)\n                            x, y, current_heading = map.pose()\n                            print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                            turns_made += 1\n                        if turns_made >= max_turns:\n                            print(\"Warning: Reached maximum number of turns without reaching desired heading; keeping current heading.\")\n                            return\n                    else:\n                        print(\"No more valid headings to explore at this intersection\")\n                        return\n                \n                inter = map.intersections.get((x, y))\n                if has_street:\n                    if inter.streets[h] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                    for delta in [-1, 1, -3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                else:\n                    map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                    for delta in [-3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            if result == \"end\":\n                print(\"Dead end detected - executing U-turn\")\n                original_x, original_y, original_heading = map.markdeadend()\n                # Calculate new heading after U-turn\n                handle_deadend(map, behaviors, original_x, original_y, original_heading)\n                x, y, current_heading = map.pose()\n                print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                \n                # After marking dead end, find and align to a valid street before continuing\n                valid_headings = [h for h in range(8) \n                                if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED, STATUS.CONNECTED)\n                                and not map.is_blocked(x, y, h)\n                                and current_intersection.streets[h] != STATUS.DEADEND]\n                if valid_headings:\n                    best_heading = min(valid_headings,\n                                    key=lambda h: min((h - current_heading) % 8,\n                                                    (current_heading - h) % 8))\n                    print(f\"Aligning to valid street at heading {best_heading}\")\n                    diff = (best_heading - current_heading) % 8\n                    counter_diff = (current_heading - best_heading) % 8\n                    turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                    \n                    while current_heading != best_heading:\n                        turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                        map.markturn(turn_amt, actual_angle)\n                        x, y, current_heading = map.pose()\n                        print(f\"After alignment turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                return\n    else:\n        print(\"No unblocked unknown streets left to explore at this intersection.\")\n\n    # Step 2: Check for UNEXPLORED streets (skip blocked)\n    unexplored_headings = [h for h in range(8)\n                            if current_intersection.streets[h] == STATUS.UNEXPLORED \n                            and not map.is_blocked(x, y, h)]\n    print(f\"\\nUnblocked unexplored streets at headings: {unexplored_headings}\")\n    \n    if unexplored_headings:\n        # Find heading with smallest rotation needed\n        best_heading = min(unexplored_headings,\n                            key=lambda h: min((h - current_heading) % 8,\n                                            (current_heading - h) % 8))\n        diff = (best_heading - current_heading) % 8\n        counter_diff = (current_heading - best_heading) % 8\n        if diff <= counter_diff:\n            turn_direction = \"left\"\n        else:\n            turn_direction = \"right\"\n        \n        print(f\"Found unexplored street at heading {best_heading}, turning {turn_direction}\")\n        prev_heading = current_heading  # Initialize prev_heading\n        max_turns = 4  # Maximum number of turns to prevent infinite loop\n        turns_made = 0  # Initialize turns_made\n        \n        while current_heading != best_heading and turns_made < max_turns:\n            turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n            map.markturn(turn_amt, actual_angle)\n            x, y, current_heading = map.pose()\n            \n            print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            \n            # Check if we're making progress towards the desired heading\n            current_diff = (best_heading - current_heading) % 8\n            prev_diff = (best_heading - prev_heading) % 8\n            if current_diff >= prev_diff:\n                print(\"Warning: Not making progress towards desired heading, stopping\")\n                break\n                \n            prev_heading = current_heading\n            turns_made += 1\n            \n            # Add a small delay between turns to prevent rapid spinning\n            time.sleep(0.1)\n\n        if turns_made >= max_turns:\n            print(\"Warning: Reached maximum number of turns without reaching desired heading; keeping current heading.\")\n            return\n\n        # Check for blockage before moving forward\n        blocked = behaviors.check_blockage(current_heading)\n        if blocked:\n            print(f\"Street at heading {current_heading} is blocked, marking as blocked\")\n            map.set_blocked(x, y, current_heading, True)\n            # Find next valid heading to explore\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                best_heading = min(valid_headings,\n                                key=lambda h: min((h - current_heading) % 8,\n                                                (current_heading - h) % 8))\n                print(f\"Turning to next valid heading {best_heading}\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                turns_made = 0\n                max_turns = 4\n                while current_heading != best_heading and turns_made < max_turns:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                    turns_made += 1\n                if turns_made >= max_turns:\n                    print(\"Warning: Reached maximum number of turns without reaching desired heading; keeping current heading.\")\n                    return\n            else:\n                print(\"No more valid headings to explore at this intersection\")\n                return\n        else:\n            result = behaviors.follow_line()\n            if result == \"intersection\":\n                has_street = behaviors.pull_forward()\n                map.update_connection()\n                x, y, h = map.pose()\n                print(f\"Reached intersection - Position: ({x}, {y}), Heading: {h}\")\n                print(f\"Street ahead exists: {has_street}\")\n                \n                # Check for blockage at the intersection\n                blocked = behaviors.check_blockage(h)\n                if blocked:\n                    print(f\"Street at heading {h} is blocked, marking as blocked\")\n                    map.set_blocked(x, y, h, True)\n                    # Mark diagonals as NONEXISTENT if they are UNKNOWN\n                    if has_street:\n                        inter = map.getintersection(x, y)\n                        for delta in [-1, 1, -3, 3]:\n                            diag = (h + delta) % 8\n                            if inter.streets[diag] == STATUS.UNKNOWN:\n                                map.setstreet(x, y, diag, STATUS.NONEXISTENT)\n                    else:\n                        inter = map.getintersection(x, y)\n                        for delta in [-3, 3]:\n                            diag = (h + delta) % 8\n                            if inter.streets[diag] == STATUS.UNKNOWN:\n                                map.setstreet(x, y, diag, STATUS.NONEXISTENT)\n\n                    # Find next valid heading to explore\n                    valid_headings = [h for h in range(8) \n                                    if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                                    and not map.is_blocked(x, y, h)\n                                    and current_intersection.streets[h] != STATUS.DEADEND]\n                    if valid_headings:\n                        best_heading = min(valid_headings,\n                                        key=lambda h: min((h - current_heading) % 8,\n                                                        (current_heading - h) % 8))\n                        print(f\"Turning to next valid heading {best_heading}\")\n                        diff = (best_heading - current_heading) % 8\n                        counter_diff = (current_heading - best_heading) % 8\n                        turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                        \n                        turns_made = 0\n                        max_turns = 4\n                        while current_heading != best_heading and turns_made < max_turns:\n                            turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                            map.markturn(turn_amt, actual_angle)\n                            x, y, current_heading = map.pose()\n                            print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                            turns_made += 1\n                        if turns_made >= max_turns:\n                            print(\"Warning: Reached maximum number of turns without reaching desired heading; keeping current heading.\")\n                            return\n                    else:\n                        print(\"No more valid headings to explore at this intersection\")\n                        return\n                \n                inter = map.intersections.get((x, y))\n                if has_street:\n                    if inter.streets[h] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                    for delta in [-1, 1, -3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                else:\n                    map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                    for delta in [-3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            if result == \"end\":\n                print(\"Dead end detected - executing U-turn\")\n                original_x, original_y, original_heading = map.markdeadend()\n                # Calculate new heading after U-turn\n                handle_deadend(map, behaviors, original_x, original_y, original_heading)\n                x, y, current_heading = map.pose()\n                print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                \n                # After marking dead end, find and align to a valid street before continuing\n                valid_headings = [h for h in range(8) \n                                if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED, STATUS.CONNECTED)\n                                and not map.is_blocked(x, y, h)\n                                and current_intersection.streets[h] != STATUS.DEADEND]\n                if valid_headings:\n                    best_heading = min(valid_headings,\n                                    key=lambda h: min((h - current_heading) % 8,\n                                                    (current_heading - h) % 8))\n                    print(f\"Aligning to valid street at heading {best_heading}\")\n                    diff = (best_heading - current_heading) % 8\n                    counter_diff = (current_heading - best_heading) % 8\n                    turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                    \n                    while current_heading != best_heading:\n                        turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                        map.markturn(turn_amt, actual_angle)\n                        x, y, current_heading = map.pose()\n                        print(f\"After alignment turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                return\n    else:\n        print(\"No unblocked unexplored streets left to explore at this intersection.\")\n\n    # Use Dijkstra's to find nearest intersection with unknown/unexplored streets\n    found_goal = False\n    min_distance = float('inf')\n    best_goal = None\n    \n    print(\"\\nSearching for nearest intersection with unknown/unexplored streets...\")\n    # First check all intersections for unknown/unexplored streets\n    for tx, ty in map.intersections.keys():\n        inter = map.intersections[(tx, ty)]\n        unknown_or_unexplored = [h for h in range(8) \n                               if inter.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED) \n                               and not map.is_blocked(tx, ty, h)]\n        if unknown_or_unexplored:\n            # manhattan distance\n            distance = abs(tx - x) + abs(ty - y)\n            print(f\"Found intersection at ({tx}, {ty}) with unknown/unexplored streets at headings {unknown_or_unexplored}, distance: {distance}\")\n            if distance < min_distance:\n                min_distance = distance\n                best_goal = (tx, ty)\n    \n    if best_goal:\n        tx, ty = best_goal\n        print(f\"\\nSetting goal to nearest intersection ({tx}, {ty}) with unknown/unexplored streets\")\n        print(f\"Current position: ({x}, {y}), Distance to goal: {min_distance}\")\n        map.dijkstra(tx, ty)\n        found_goal = True\n        \n        print(\"Navigating to next unexplored area...\")\n        if map.goal is not None:\n            map.showwithrobot()\n            step_toward_goal(map, behaviors)\n            x, y, current_heading = map.pose()\n            print(f\"Moving to goal - Position: ({x}, {y}), Heading: {current_heading}\")\n    else:\n        print(\"Exploration complete! No more unknown or unexplored streets.\")\n        return\n\n\ndef get_heading_toward_goal(current_pos, goal_pos):\n    \"\"\"Calculate the heading that points toward the goal from current position.\"\"\"\n    dx = goal_pos[0] - current_pos[0]\n    dy = goal_pos[1] - current_pos[1]\n    \n    # Calculate angle in radians\n    angle = math.atan2(dy, dx)\n    \n    # Convert to heading (0-7, where 0 is East, 2 is South, 4 is West, 6 is North)\n    heading = int(round(angle * 4 / math.pi)) % 8\n    \n    return heading\n\ndef is_heading_toward_goal(current_pos, current_heading, goal_pos):\n    \"\"\"Check if the current heading is taking us toward the goal.\"\"\"\n    # Get the ideal heading toward goal\n    ideal_heading = get_heading_toward_goal(current_pos, goal_pos)\n    \n    # Calculate how far we are from the ideal heading\n    heading_diff = min((current_heading - ideal_heading) % 8,\n                      (ideal_heading - current_heading) % 8)\n    \n    # If we're within 1 step of the ideal heading, we're heading toward the goal\n    return heading_diff <= 1\n\ndef directed_exploration(map, behaviors, goal):\n    \"\"\"\n    Directed exploration: like autonomous_step, but when using Dijkstra to pick the next intersection,\n    use the advanced logic: for each interesting intersection, sum the Dijkstra cost from the robot to the intersection\n    and the Euclidean distance from that intersection to the ultimate goal. Pick the intersection with the lowest total cost as the next goal.\n    \"\"\"\n    print(\"Directed exploration mode: Robot is exploring the map toward a yet-to-be-discovered goal...\")\n    x, y, current_heading = map.pose()\n    print(f\"\\nCurrent Position: ({x}, {y}), Heading: {current_heading}\")\n    current_intersection = map.intersections.get((x, y))\n\n    # Check if we've reached the goal intersection\n    if (x, y) == goal:\n        print(\"Goal intersection reached! Stopping exploration.\")\n        inter = map.intersections.get((x, y))\n        if inter:\n            if inter.streets[current_heading] == STATUS.UNKNOWN:\n                map.setstreet(x, y, current_heading, STATUS.UNEXPLORED)\n            # Mark diagonals as NONEXISTENT\n            for delta in [-1, 1, -3, 3]:\n                diag_heading = (current_heading + delta) % 8\n                if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                    print(f\"Marked diagonal street at heading {diag_heading} as NONEXISTENT\")\n        return\n\n    if not current_intersection:\n        print(\"Error: Robot not at a valid intersection\")\n        return\n\n    # Print current intersection state\n    print(\"\\nCurrent intersection street states:\")\n    for h in range(8):\n        status = current_intersection.streets[h]\n        blocked = current_intersection.blocked[h] if hasattr(current_intersection, 'blocked') else False\n        print(f\"Heading {h}: {status} {'(BLOCKED)' if blocked else ''}\")\n\n    # Function to calculate where we would end up if we went in a given heading\n    def get_potential_position(heading):\n        # Calculate the next intersection position based on heading\n        # Headings: 0=North, 1=Northwest, 2=West, 3=Southwest, 4=South, 5=Southeast, 6=East, 7=Northeast\n        dx = [0, -1, -1, -1, 0, 1, 1, 1]  # x changes for each heading\n        dy = [1, 1, 0, -1, -1, -1, 0, 1]  # y changes for each heading\n        return (x + dx[heading], y + dy[heading])\n\n    # Step 1: Check for UNKNOWN streets (skip blocked)\n    unknown_and_unexplored_headings = [h for h in range(8)\n                        if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                        and not map.is_blocked(x, y, h)]\n    print(f\"\\nUnblocked unknown streets at headings: {unknown_and_unexplored_headings}\")\n\n    if unknown_and_unexplored_headings:\n        # Calculate potential positions and their distances to goal for each unknown heading\n        heading_distances = []\n        for heading in unknown_and_unexplored_headings:\n            potential_pos = get_potential_position(heading)\n            distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n            heading_distances.append((heading, distance))\n        \n        # Choose the heading that leads to the position closest to the goal\n        best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n        print(f\"[DEBUG] Found unknown street leading closest to goal - Best heading: {best_heading}, Distance: {best_distance}\")\n        \n        # Skip turning if we're already at the best heading\n        if best_heading == current_heading:\n            print(\"[DEBUG] Already at best heading, no need to turn\")\n        else:\n            diff = (best_heading - current_heading) % 8\n            counter_diff = (current_heading - best_heading) % 8\n            turn_direction = \"left\" if diff <= counter_diff else \"right\"\n            print(f\"[DEBUG] Turning {turn_direction} from {current_heading} to {best_heading}\")\n            \n            # Rest of the unknown streets handling code remains the same\n            prev_heading = current_heading\n            max_turns = 4\n            turns_made = 0\n            while current_heading != best_heading and turns_made < max_turns:\n                turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                map.markturn(turn_amt, actual_angle)\n                x, y, current_heading = map.pose()\n                current_diff = (best_heading - current_heading) % 8\n                prev_diff = (best_heading - prev_heading) % 8\n                if current_diff >= prev_diff:\n                    print(\"Warning: Not making progress towards desired heading, stopping\")\n                    break\n                prev_heading = current_heading\n                turns_made += 1\n                time.sleep(0.1)\n            if turns_made >= max_turns:\n                print(\"Warning: Reached maximum number of turns without reaching desired heading\")\n                map.set_pose(x, y, best_heading)\n                return\n        blocked = behaviors.check_blockage(current_heading)\n        if blocked:\n            print(f\"Street at heading {current_heading} is blocked, marking as blocked\")\n            map.set_blocked(x, y, current_heading, True)\n            # Find next valid heading to explore, using same distance-based logic\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                # Calculate distances for valid headings\n                heading_distances = []\n                for heading in valid_headings:\n                    potential_pos = get_potential_position(heading)\n                    distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n                    heading_distances.append((heading, distance))\n                best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n                print(f\"Turning to next valid heading {best_heading} (closest to goal, distance: {best_distance})\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                while current_heading != best_heading:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n                    \n            else:\n                print(\"No more valid headings to explore at this intersection\")\n                return\n        result = behaviors.follow_line()\n        if result == \"intersection\":\n            has_street = behaviors.pull_forward()\n            map.update_connection()\n            x, y, h = map.pose()\n            print(f\"Reached intersection - Position: ({x}, {y}), Heading: {h}\")\n            \n            # Update street status for all intersections, not just the goal\n            inter = map.intersections.get((x, y))\n            if has_street:\n                if inter.streets[h] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                for delta in [-1, 1, -3, 3]:\n                    diag_heading = (h + delta) % 8\n                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            else:\n                map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                for delta in [-3, 3]:\n                    diag_heading = (h + delta) % 8\n                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            \n            # Check if we've reached the goal intersection\n            if (x, y) == goal:\n                inter = map.intersections.get((x, y))\n                if has_street:\n                    if inter.streets[h] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                    for delta in [-1, 1, -3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n                else:\n                    map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                    for delta in [-3, 3]:\n                        diag_heading = (h + delta) % 8\n                        if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                            map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n\n            blocked = behaviors.check_blockage(h)\n            print(\"Goal intersection reached! Stopping exploration.\")  \n            if blocked:\n                print(f\"Street at heading {h} is blocked, marking as blocked\")\n                map.set_blocked(x, y, h, True)\n                return\n\n        elif result == \"end\":\n            print(\"Dead end detected - executing U-turn\")\n            original_x, original_y, original_heading = map.markdeadend()\n            # Calculate new heading after U-turn\n            handle_deadend(map, behaviors, original_x, original_y, original_heading)\n            x, y, current_heading = map.pose()\n            print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            # Find next valid heading to explore using distance-based logic\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                # Calculate distances for valid headings\n                heading_distances = []\n                for heading in valid_headings:\n                    potential_pos = get_potential_position(heading)\n                    distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n                    heading_distances.append((heading, distance))\n                best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n                print(f\"Turning to next valid heading {best_heading} (closest to goal, distance: {best_distance})\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                while current_heading != best_heading:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            else:\n                print(\"No more valid headings to explore at this intersection\")\n                return\n            \n            # After marking dead end, find and align to a valid street before continuing\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED, STATUS.CONNECTED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                # Calculate distances for valid headings\n                heading_distances = []\n                for heading in valid_headings:\n                    potential_pos = get_potential_position(heading)\n                    distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n                    heading_distances.append((heading, distance))\n                best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n                print(f\"Aligning to valid street at heading {best_heading} (closest to goal, distance: {best_distance})\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                while current_heading != best_heading:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After alignment turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            return\n    else:\n        print(\"No unblocked unknown streets left to explore at this intersection.\")\n\n    # Step 2: Check for UNEXPLORED streets (skip blocked)\n    unexplored_headings = [h for h in range(8)\n                            if current_intersection.streets[h] == STATUS.UNEXPLORED \n                            and not map.is_blocked(x, y, h)]\n    print(f\"\\nUnblocked unexplored streets at headings: {unexplored_headings}\")\n    if unexplored_headings:\n        # Calculate potential positions and their distances to goal for each unexplored heading\n        heading_distances = []\n        for heading in unexplored_headings:\n            potential_pos = get_potential_position(heading)\n            distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n            heading_distances.append((heading, distance))\n        \n        # Choose the heading that leads to the position closest to the goal\n        best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n        print(f\"[DEBUG] Found unexplored street leading closest to goal - Best heading: {best_heading}, Distance: {best_distance}\")\n        \n        # Skip turning if we're already at the best heading\n        if best_heading == current_heading:\n            print(\"[DEBUG] Already at best heading, no need to turn\")\n        else:\n            diff = (best_heading - current_heading) % 8\n            counter_diff = (current_heading - best_heading) % 8\n            turn_direction = \"left\" if diff <= counter_diff else \"right\"\n            print(f\"[DEBUG] Turning {turn_direction} from {current_heading} to {best_heading}\")\n            \n            # Rest of the unexplored streets handling code remains the same\n            prev_heading = current_heading\n            max_turns = 4\n            turns_made = 0\n            while current_heading != best_heading and turns_made < max_turns:\n                turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                map.markturn(turn_amt, actual_angle)\n                x, y, current_heading = map.pose()\n                current_diff = (best_heading - current_heading) % 8\n                prev_diff = (best_heading - prev_heading) % 8\n                if current_diff >= prev_diff:\n                    print(\"Warning: Not making progress towards desired heading, stopping\")\n                    break\n                prev_heading = current_heading\n                turns_made += 1\n                time.sleep(0.1)\n            if turns_made >= max_turns:\n                print(\"Warning: Reached maximum number of turns without reaching desired heading\")\n                map.set_pose(x, y, best_heading)\n                return\n        blocked = behaviors.check_blockage(current_heading)\n        if blocked:\n            print(f\"Street at heading {current_heading} is blocked, marking as blocked\")\n            map.set_blocked(x, y, current_heading, True)\n            # Find next valid heading to explore, using same distance-based logic\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                # Calculate distances for valid headings\n                heading_distances = []\n                for heading in valid_headings:\n                    potential_pos = get_potential_position(heading)\n                    distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n                    heading_distances.append((heading, distance))\n                best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n                print(f\"Turning to next valid heading {best_heading} (closest to goal, distance: {best_distance})\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                while current_heading != best_heading:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            else:\n                print(\"No more valid headings to explore at this intersection\")\n                return\n        result = behaviors.follow_line()\n        if result == \"intersection\":\n            has_street = behaviors.pull_forward()\n            map.update_connection()\n            x, y, h = map.pose()\n            print(f\"Reached intersection - Position: ({x}, {y}), Heading: {h}\")\n            \n            # Update street status for all intersections, not just the goal\n            inter = map.intersections.get((x, y))\n            if has_street:\n                if inter.streets[h] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                for delta in [-1, 1, -3, 3]:\n                    diag_heading = (h + delta) % 8\n                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            else:\n                map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                for delta in [-3, 3]:\n                    diag_heading = (h + delta) % 8\n                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            \n            # Check if we've reached the goal intersection\n            if (x, y) == goal:\n                print(\"Goal intersection reached! Stopping exploration.\")\n                return\n                \n            inter = map.intersections.get((x, y))\n            if has_street:\n                if inter.streets[h] == STATUS.UNKNOWN:\n                    map.setstreet(x, y, h, STATUS.UNEXPLORED)\n                for delta in [-1, 1, -3, 3]:\n                    diag_heading = (h + delta) % 8\n                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            else:\n                map.setstreet(x, y, h, STATUS.NONEXISTENT)\n                for delta in [-3, 3]:\n                    diag_heading = (h + delta) % 8\n                    if inter.streets[diag_heading] == STATUS.UNKNOWN:\n                        map.setstreet(x, y, diag_heading, STATUS.NONEXISTENT)\n            blocked = behaviors.check_blockage(h)\n            if blocked:\n                print(f\"Street at heading {h} is blocked, marking as blocked\")\n                map.set_blocked(x, y, h, True)\n                return\n        elif result == \"end\":\n            print(\"Dead end detected - executing U-turn\")\n            original_x, original_y, original_heading = map.markdeadend()\n            # Calculate new heading after U-turn\n            handle_deadend(map, behaviors, original_x, original_y, original_heading)\n            x, y, current_heading = map.pose()\n            print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            # Find next valid heading to explore using distance-based logic\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                # Calculate distances for valid headings\n                heading_distances = []\n                for heading in valid_headings:\n                    potential_pos = get_potential_position(heading)\n                    distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n                    heading_distances.append((heading, distance))\n                best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n                print(f\"Turning to next valid heading {best_heading} (closest to goal, distance: {best_distance})\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                while current_heading != best_heading:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            else:\n                print(\"No more valid headings to explore at this intersection\")\n                return\n            print(\"No blockage detected - executing U-turn\")\n            original_x, original_y, original_heading = map.markdeadend()\n            time.sleep(0.1)\n            handle_deadend(map, behaviors, original_x, original_y, original_heading)\n            x, y, current_heading = map.pose()\n            print(f\"After U-turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            \n            # After marking dead end, find and align to a valid street before continuing\n            valid_headings = [h for h in range(8) \n                            if current_intersection.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED, STATUS.CONNECTED)\n                            and not map.is_blocked(x, y, h)\n                            and current_intersection.streets[h] != STATUS.DEADEND]\n            if valid_headings:\n                # Calculate distances for valid headings\n                heading_distances = []\n                for heading in valid_headings:\n                    potential_pos = get_potential_position(heading)\n                    distance = math.sqrt((potential_pos[0] - goal[0])**2 + (potential_pos[1] - goal[1])**2)\n                    heading_distances.append((heading, distance))\n                best_heading, best_distance = min(heading_distances, key=lambda x: x[1])\n                print(f\"Aligning to valid street at heading {best_heading} (closest to goal, distance: {best_distance})\")\n                diff = (best_heading - current_heading) % 8\n                counter_diff = (current_heading - best_heading) % 8\n                turn_direction = \"left\" if diff <= counter_diff else \"right\"\n                \n                while current_heading != best_heading:\n                    turn_amt, actual_angle = behaviors.turning_behavior(turn_direction)\n                    map.markturn(turn_amt, actual_angle)\n                    x, y, current_heading = map.pose()\n                    print(f\"After alignment turn - Position: ({x}, {y}), Heading: {current_heading}\")\n            return\n    else:\n        print(\"No unblocked unexplored streets left to explore at this intersection.\")\n\n    # Advanced Dijkstra logic: find the best intersection to explore next\n    print(\"\\nSearching for best intersection to explore using Dijkstra + Euclidean heuristic...\")\n    candidates = []\n    for (tx, ty), inter in map.intersections.items():\n        if any(inter.streets[h] in (STATUS.UNKNOWN, STATUS.UNEXPLORED) and not map.is_blocked(tx, ty, h) for h in range(8)):\n            map.dijkstra(tx, ty)\n            # Assume map.get_cost(tx, ty) returns the Dijkstra cost from current position to (tx, ty)\n            cost_to_reach = getattr(map, 'get_cost', lambda tx, ty: abs(tx - x) + abs(ty - y))(tx, ty)\n            heuristic_cost = math.sqrt((tx - goal[0]) ** 2 + (ty - goal[1]) ** 2)\n            total_cost = cost_to_reach + heuristic_cost\n            candidates.append(((tx, ty), total_cost))\n    \n    if candidates:\n        best_goal, _ = min(candidates, key=lambda x: x[1])\n        print(f\"\\nSetting goal to best intersection {best_goal} (lowest total cost)\")\n        map.dijkstra(*best_goal)\n        if map.goal is not None:\n            map.showwithrobot()\n            step_toward_goal(map, behaviors)\n            x, y, current_heading = map.pose()\n            print(f\"Moving to goal - Position: ({x}, {y}), Heading: {current_heading}\")\n            \n            # Check if we've reached the goal intersection\n            if (x, y) == goal:\n                print(\"Goal intersection reached! Stopping exploration.\")\n                return\n    else:\n        # Check if we've explored all possible paths to the goal\n        map.dijkstra(goal[0], goal[1])\n        if map.goal is None:\n            print(\"\\nNo possible paths to goal intersection found. All possible paths have been exhausted.\")\n            print(\"Please enter a new command.\")\n            behaviors.drive.stop()  # Stop the robot\n            return\n        else:\n            print(\"\\nAll possible paths to goal have been explored. Please enter a new command.\")\n            behaviors.drive.stop()  # Stop the robot\n            return\n\n\n\n",
  "MapBuilding.py": "import os\nimport time\nimport pickle\nfrom enum import Enum\nimport matplotlib.pyplot as plt\nimport traceback\n\n\nclass STATUS(Enum):\n    UNKNOWN = 0\n    NONEXISTENT = 1\n    UNEXPLORED = 2\n    DEADEND = 3\n    CONNECTED = 4\n\n\nclass Intersection:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.streets = [STATUS.UNKNOWN for i in range(8)]\n        self.blocked = [False for _ in range(8)]  # Blocked flags for each direction\n        self.cost = float('inf')\n        self.direction = None\n\n    def set_blocked(self, heading, value: bool):\n        self.blocked[heading] = value\n\n    def is_blocked(self, heading) -> bool:\n        return self.blocked[heading]\n\n        \n# load map from file if it exists, otherwise create a new map\ndef prompt_and_load_map():\n    filename = input(\"Enter filename to load (e.g. mymap.pickle): \").strip()\n    try:\n        with open(filename, 'rb') as file:\n            map = pickle.load(file)\n        print(f\"Map loaded from {filename}.\")\n        return map\n    except FileNotFoundError:\n        print(f\"File {filename} not found. Starting with a blank map.\")\n    except Exception as e:\n        print(f\"Failed to load map: {e}\")\n        print(\"Starting with a blank map instead.\")\n\nclass Map:\n    # Define the heading to delta mapping\n    heading_to_delta = {\n        0: (0, 1), \n        1: (-1, 1), \n        2: (-1, 0), \n        3: (-1, -1),\n        4: (0, -1), \n        5: (1, -1), \n        6: (1, 0), \n        7: (1, 1)\n    }\n\n    # Define the heading vectors for plotting\n    heading_vectors = {\n        0: (0.0, 0.5), \n        1: (-0.5, 0.5), \n        2: (-0.5, 0.0), \n        3: (-0.5, -0.5),\n        4: (0.0, -0.5), \n        5: (0.5, -0.5), \n        6: (0.5, 0.0), \n        7: (0.5, 0.5)\n    }\n\n    # defines the color mapping for each status\n    color_map = {\n        STATUS.UNKNOWN: 'black',\n        STATUS.NONEXISTENT: 'lightgray',\n        STATUS.UNEXPLORED: 'blue',\n        STATUS.DEADEND: 'red',\n        STATUS.CONNECTED: 'green'\n    }\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        self.heading = 0\n        self.intersections = {}\n        \n        self.cost = None\n        self.direction = None\n        self.goal = None\n\n\n    def pose(self):\n        return (self.x, self.y, self.heading)\n\n    def calcmove(self):\n        dx, dy = self.heading_to_delta[self.heading]\n        self.x += dx\n        self.y += dy\n\n    \n    def calcuturn(self):\n        self.heading = (self.heading + 4) % 8\n        \n\n    def getintersection(self, x, y):\n        if (x, y) not in self.intersections:\n            self.intersections[(x, y)] = Intersection(x, y)\n        return self.intersections[(x, y)]\n    \n    def has_intersection(self, x, y):\n        return (x, y) in self.intersections\n\n    def setstreet(self, x, y, heading, status):\n        # Set status for current intersection\n        inter = self.getintersection(x, y)\n        # Never overwrite a DEADEND or CONNECTED status\n        if inter.streets[heading] not in (STATUS.DEADEND, STATUS.CONNECTED):\n            inter.streets[heading] = status\n\n        # Also update the reverse direction of the neighbor\n        dx, dy = self.heading_to_delta[heading]\n        nx, ny = x + dx, y + dy\n        if (nx, ny) in self.intersections:\n            neighbor = self.intersections[(nx, ny)]\n            # Never overwrite a DEADEND or CONNECTED status\n            if neighbor.streets[(heading + 4) % 8] not in (STATUS.DEADEND, STATUS.CONNECTED):\n                neighbor.streets[(heading + 4) % 8] = status\n\n\n    def markturn(self, turn_amount, actual_angle=None):\n        current = self.getintersection(self.x, self.y)\n        \n        prev_heading = self.heading\n        # prev_heading = (self.heading - turn_amount) % 8\n        new_heading = (self.heading + turn_amount) % 8\n\n\n        # Check if we landed on a NONEXISTENT street\n        if current.streets[new_heading] == STATUS.NONEXISTENT and actual_angle is not None:\n            # Only consider headings \u00b11 away from current heading\n            valid_headings = []\n            for delta in [-2,-1,1,2]:\n                h = (new_heading + delta) % 8\n                if current.streets[h] != STATUS.NONEXISTENT:\n                    valid_headings.append(h)\n            \n            \n            if valid_headings:\n                # Find the heading closest to the measured angle\n                best_heading = None\n                min_diff = 360\n                \n                for h in valid_headings:\n                    # Calculate degrees for this heading (0=0\u00b0, 1=45\u00b0, 2=90\u00b0, etc)\n                    # degrees = h * 45\n                    heading = h\n                    if heading == 0:\n                        heading = 8\n                    \n                    degrees = abs((prev_heading - heading) * 45) % 360\n                    # If it's a right turn (negative angle), make the degrees negative\n                    if actual_angle < 0:\n                        degrees = -degrees\n                    \n                    # Calculate angle difference\n                    diff = abs(degrees - actual_angle)\n                    \n                    \n                    if diff < min_diff:\n                        min_diff = diff\n                        best_heading = h\n        \n                    \n                print(f\"Correcting heading from {self.heading} to {best_heading} based on angle sensor (measured={actual_angle:.1f}\u00b0, chosen={degrees}\u00b0)\")\n                # If we're turning onto an UNKNOWN street, mark it as UNEXPLORED\n                if (current.streets[best_heading] == STATUS.NONEXISTENT) or (current.streets[best_heading] == STATUS.UNKNOWN): \n                    current.streets[best_heading] = STATUS.UNEXPLORED\n                self.heading = best_heading\n                    \n                    \n        else:\n            # If no correction needed and we're on an UNKNOWN street, mark it as UNEXPLORED\n            if current.streets[new_heading] == STATUS.UNKNOWN:\n                current.streets[new_heading] = STATUS.UNEXPLORED\n            self.heading = new_heading\n\n            \n\n        skipped = []\n        if turn_amount > 0:\n            # Start from one after prev_heading to avoid marking it\n            for i in range(1, turn_amount):\n                skipped_heading = (prev_heading + i) % 8\n                if skipped_heading != prev_heading and skipped_heading != self.heading:  # Don't include the heading we started from or ended at\n                    skipped.append(skipped_heading)\n        elif turn_amount < 0:\n            # Start from one after prev_heading to avoid marking it\n            for i in range(-1, turn_amount, -1):\n                skipped_heading = (prev_heading + i) % 8\n                if skipped_heading != prev_heading and skipped_heading != self.heading:  # Don't include the heading we started from or ended at\n                    skipped.append(skipped_heading)\n\n        for d in skipped:\n            if current.streets[d] in (STATUS.UNKNOWN, STATUS.UNEXPLORED):\n                current.streets[d] = STATUS.NONEXISTENT\n\n        for delta in [-1, 1]:\n            diag = (self.heading + delta) % 8\n            self.setstreet(self.x, self.y, diag, STATUS.NONEXISTENT)\n\n    def possible_angles(self, heading, turn_amount=None):\n        inter = self.getintersection(self.x, self.y)\n        possible_angles = []\n        for i in range(len(inter.streets)):\n            if inter.streets[i] != STATUS.NONEXISTENT:\n                angle = (i - heading) * 45\n                if angle == 0:\n                    continue  # skip straight ahead\n                possible_angles.append(angle)\n        return possible_angles\n\n    def update_connection(self):\n        dx, dy = self.heading_to_delta[self.heading]\n        next_x = self.x + dx\n        next_y = self.y + dy\n        heading = self.heading\n\n        # Mark the forward direction as CONNECTED (from current to next)\n        current = self.getintersection(self.x, self.y)\n        if current.streets[heading] != STATUS.DEADEND:\n            current.streets[heading] = STATUS.CONNECTED\n            \n        # Mark the reverse direction as CONNECTED (from next back to current)\n        reverse_heading = (heading + 4) % 8\n        next_inter = self.getintersection(next_x, next_y)\n        if next_inter.streets[reverse_heading] != STATUS.DEADEND:\n            next_inter.streets[reverse_heading] = STATUS.CONNECTED\n\n        # Update robot's position\n        self.x = next_x\n        self.y = next_y\n\n    def markdeadend(self):\n        print(\"Reached end of the street.\")\n        current_intersection = self.getintersection(self.x, self.y)\n        # Only mark as DEADEND if it wasn't already marked as NONEXISTENT\n        if current_intersection.streets[self.heading] != STATUS.NONEXISTENT:\n            current_intersection.streets[self.heading] = STATUS.DEADEND\n\n        # Store the original position and heading before U-turn\n        original_x, original_y = self.x, self.y\n        original_heading = self.heading\n        print(f\"[DEBUG] Before U-turn: x={original_x}, y={original_y}, heading={original_heading}\")\n\n        # Return the original position and heading\n        return original_x, original_y, original_heading\n\n    \n\n    def showwithrobot(self):\n        self.show()  \n        dx, dy = self.heading_vectors[self.heading]\n        plt.arrow(self.x, self.y, dx, dy,\n                width=0.2, head_width=0.3, head_length=0.1, color='magenta')\n\n        plt.pause(0.001)\n\n    def show(self):\n        plt.clf()\n        plt.axes()\n        plt.gca().set_xlim(-5, 5)\n        plt.gca().set_ylim(-5, 5)\n        plt.gca().set_aspect('equal')\n\n        for x in range(-4, 5):\n            for y in range(-4, 5):\n                plt.plot(x, y, color='lightgray', marker='o', markersize=8)\n\n        for (ix, iy), intersection in self.intersections.items():\n            for idx in range(8):\n                dx, dy = self.heading_vectors[idx]\n                status = intersection.streets[idx]\n                color = self.color_map[status]\n                linewidth = 2\n                if hasattr(intersection, 'blocked') and intersection.blocked[idx]:\n                    color = 'purple'\n                    linewidth = 4\n                plt.plot([ix, ix + dx], [iy, iy + dy], color=color, linewidth=linewidth)\n        \n        # draw optimal path to goal if it exists\n        if self.goal is not None and (self.x, self.y) in self.intersections:\n            cx, cy = self.x, self.y\n            current = self.intersections[(cx, cy)]\n            visited = set()\n\n            while current.direction is not None and (cx, cy) != self.goal:\n                visited.add((cx, cy))\n                heading = current.direction\n                dx, dy = self.heading_vectors[heading]\n                nx, ny = cx + dx, cy + dy\n\n                # Draw the segment in a distinct color \n                plt.plot([cx, nx], [cy, ny], color='orange', linewidth=3.5)\n\n                # Move to next\n                cx, cy = int(round(nx)), int(round(ny))\n                if (cx, cy) in visited or (cx, cy) not in self.intersections:\n                    break  # stop if we're looping or hit a node that doesn't exist\n                current = self.intersections[(cx, cy)]\n                \n\n        plt.pause(0.001)\n\n    def dijkstra(self, xgoal, ygoal):\n        # First check if the goal intersection exists\n        if (xgoal, ygoal) not in self.intersections:\n            print(f\"Error: Goal intersection ({xgoal}, {ygoal}) does not exist in the map.\")\n            self.goal = None\n            return\n\n        # Reset all previous cost/direction info\n        for inter in self.intersections.values():\n            inter.cost = float('inf')  # infinity\n            inter.direction = None\n\n        self.goal = (xgoal, ygoal)  \n\n        # initialize goal node\n        goal = self.getintersection(xgoal, ygoal)\n        goal.cost = 0\n        goal.direction = None\n\n        # initialize the onDeck queue with just the goal\n        onDeck = [goal]\n\n        # Helper func to insert in sorted order\n        def sortedInsert(queue, inter):\n            for i in range(len(queue)):\n                if queue[i].cost > inter.cost:\n                    queue.insert(i, inter)\n                    return\n            queue.append(inter)\n\n        while onDeck:\n            current = onDeck.pop(0)  # pop lowest-cost leaf\n            x, y = current.x, current.y\n\n            for heading in range(8):\n                # Only consider connected streets that are not blocked\n                if current.streets[heading] != STATUS.CONNECTED:\n                    continue\n                if hasattr(current, 'blocked') and current.blocked[heading]:\n                    continue  # Skip blocked streets\n\n                dx, dy = self.heading_to_delta[heading]\n                nx, ny = x + dx, y + dy\n                if (nx, ny) not in self.intersections:\n                    continue  # Skip if neighbor intersection doesn't exist\n                neighbor = self.intersections[(nx, ny)]\n\n                # we change the cost based off the heading, which tells us \n                # if we are moving straight or diagonally\n                if heading % 2 == 0:  \n                    step_cost = 1\n                else:  \n                    step_cost = 2**0.5\n\n                potential_cost = current.cost + step_cost\n\n                # found a better path to neighbor\n                if potential_cost < neighbor.cost:\n                    # remove neighbor from onDeck if it's already in there\n                    if neighbor.cost < float('inf'):\n                        try:\n                            onDeck.remove(neighbor)\n                        except ValueError:\n                            pass  \n\n                    # save cost/direction\n                    neighbor.cost = potential_cost\n                    neighbor.direction = (heading + 4) % 8  # point back toward current\n\n                    # re-insert into onDeck in sorted order\n                    sortedInsert(onDeck, neighbor)\n\n    # clear the goal and reset all intersections to unknown\n    # this is called when the goal is reached or when the user wants to clear the goal\n    def cleargoal(self):\n        self.goal = None\n        for inter in self.intersections.values():\n            inter.cost = float('inf')\n            inter.direction = None\n\n\n    # update the Brain to Include Automatic Driving to a Goal\n    # for calling goto function in brain\n    \n\n    def set_pose(self, x, y, heading):\n        self.x = x\n        self.y = y\n        self.heading = heading\n\n    def set_position(self, x, y):\n        self.x = x\n        self.y = y\n\n    def set_heading(self, heading):\n        self.heading = heading\n\n    def set_blocked(self, x, y, heading, value: bool):\n        inter = self.getintersection(x, y)\n        # Never mark a DEADEND or NONEXISTENT street as blocked\n        if inter.streets[heading] not in (STATUS.DEADEND, STATUS.NONEXISTENT):\n            inter.set_blocked(heading, value)\n            # Also block the reverse direction at the neighbor intersection\n            dx, dy = self.heading_to_delta[heading]\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in self.intersections:\n                neighbor = self.getintersection(nx, ny)\n                reverse_heading = (heading + 4) % 8\n                # Never mark a DEADEND or NONEXISTENT street as blocked\n                if neighbor.streets[reverse_heading] not in (STATUS.DEADEND, STATUS.NONEXISTENT):\n                    neighbor.set_blocked(reverse_heading, value)\n\n    def is_blocked(self, x, y, heading) -> bool:\n        inter = self.getintersection(x, y)\n        return inter.is_blocked(heading)\n\n    def clear_blockages(self):\n        \"\"\"Clear all blockages from all intersections in the map.\"\"\"\n        for intersection in self.intersections.values():\n            for heading in range(8):\n                intersection.set_blocked(heading, False)\n        print(\"All blockages have been cleared from the map.\")\n\n    def get_cost(self, x, y):\n        \"\"\"\n        Return the cost to reach intersection (x, y) after running dijkstra.\n        If the intersection does not exist, return float('inf').\n        \"\"\"\n        inter = self.intersections.get((x, y))\n        if inter is not None:\n            return inter.cost\n        else:\n            return float('inf')\n\n\n\n\n\n\n",
  "DriveSystem.py": "import pigpio\nimport sys\nimport time\nimport traceback\n\n\nclass Motor:\n    \"\"\"\n    Motor class to control bidirectional motors via PWM using pigpio.\n    \"\"\"\n    def __init__(self, io, pinA, pinB):\n        \"\"\"\n        Initializes motor instance\n\n        Parameters:\n        - io (pigpio.pi): The pigpio interface for controlling GPIO pins\n        - pinA (int): GPIO pin number for one motor input\n        - pinB (int): GPIO pin number for the other motor input\n\n        Sets both pins to output mode, configures their PWM frequency and range,\n        and initializes with a duty cycle of 0\n        \"\"\"\n        self.io = io\n        self.pinA = pinA\n        self.pinB = pinB\n\n        # Configure pinA and pinB as outputs using pigpio\n        io.set_mode(self.pinA, pigpio.OUTPUT)\n        io.set_mode(self.pinB, pigpio.OUTPUT)\n\n        # Set pwm range and frequency\n        io.set_PWM_range(self.pinA, 255)\n        io.set_PWM_range(self.pinB, 255)\n\n        io.set_PWM_frequency(self.pinA, 1000)\n        io.set_PWM_frequency(self.pinB, 1000)\n\n        #set duty cycle to 0\n        self.stop()\n\n\n    # stop method\n    def stop(self):\n        \"\"\" \n        Stopping motors by setting PWM to 0\n        \"\"\"\n        self.setLevel(0)\n\n\n    # setLevel method\n    def setLevel(self, level):\n        \"\"\"\n        Sets motor's direction and speed.\n\n        Parameters:\n        - level (float): Value of motor power level between -1.0 and 1.0\n        Positive value spins the motor forward, and negative reverses it.\n\n        Converts the level to a PWM duty cycle and sets the appropriate pin.\n        \"\"\"\n\n        pwm_value = int(abs(level) * 250)\n\n        if level >= 0:\n            self.io.set_PWM_dutycycle(self.pinB, pwm_value)\n            self.io.set_PWM_dutycycle(self.pinA, 0)\n        elif level < 0:\n            self.io.set_PWM_dutycycle(self.pinA, pwm_value)\n            self.io.set_PWM_dutycycle(self.pinB, 0)\n        else:\n            self.io.set_PWM_dutycycle(self.pinA, 0)\n            self.io.set_PWM_dutycycle(self.pinB, 0)\n\n\n\nclass DriveSystem:\n    def __init__(self, io):\n        \"\"\"\n        Initialize the DriveSystem with two Motor instances.\n        \"\"\"\n        left_pins = (8, 7)\n        right_pins = (6, 5)\n\n        self.motor_left = Motor(io, *left_pins)\n        self.motor_right = Motor(io,*right_pins)\n\n        drive_power = 0.85\n\n        self.modes = {\"straight\" : (drive_power, drive_power), \n                      \"veer_r\" : (0.84, 0.70), \n                      \"steer_r\" : (0.90,0.66), \n                      \"turn_r\" : (0.90,0.55), \n                      \"hook_r\" : (0.87,0), \n                      \"spin_r\" : (0.83,-0.83), \n                      \"veer_l\" : (0.71, 0.82), \n                      \"steer_l\" : (0.70, 0.86), \n                      \"turn_l\" : (0.60, 0.93), \n                      \"hook_l\" : (0, 0.77),\n                      \"spin_l\" : (-0.83, 0.83)}\n\n    def stop(self):\n        \"\"\"\n        Stops both motors.\n        \"\"\"\n        self.motor_left.stop()\n        self.motor_right.stop()\n\n    def drive(self, mode, reverse=False):\n        \"\"\"\n        Looks for the mode selected as a parameter in a pre-constructed dictionary of turn modes\n        \"\"\"\n        if mode in self.modes:\n            left_level, right_level = self.modes[mode]\n            if reverse:\n                left_level = -left_level\n                right_level = -right_level\n            self.motor_left.setLevel(left_level)\n            self.motor_right.setLevel(right_level)\n        else:\n            print(\"This is not a valid drive mode\")   \n    \n    def pwm(self, PWM_L, PWM_R):\n        \"\"\"\n        Directly set the left and right motor PWM values.\n        PWM_L, PWM_R: float values between -1.0 and 1.0\n        \"\"\"\n        self.motor_left.setLevel(PWM_L)\n        self.motor_right.setLevel(PWM_R)\n\n\n\n\n\n\n\n\n       \n\n\n",
  "street_behaviors.py": "import time\nimport traceback\nimport pigpio\nfrom DriveSystem import DriveSystem\nfrom Sense import LineSensor\nfrom AngleSensor import AngleSensor\nfrom proximitysensor import ProximitySensor\nimport math\n\nclass Behaviors:\n    THRESHOLD_HIGH = 0.60\n    THRESHOLD_LOW = 0.37\n    PULL_FORWARD_DURATION = 0.36\n    PULL_FORWARD_THRESHOLD = 0.45\n    \n    # Quadratic model coefficients: y = -14.88x^2 + 162.92x - 40.47\n    # Updated regression model for time-to-angle prediction\n    TURN_COEFF_A = -14.88   # quadratic term\n    TURN_COEFF_B = 162.92   # linear term\n    TURN_COEFF_C = -40.47   # constant term\n    TURN_SCALE_FACTOR = 1.14  # Scale factor to correct 315\u00b0 to 360\u00b0\n    \n    # Weights for turn estimation\n    TIME_WEIGHT = 0.3     # Weight for time-based prediction\n    ANGLE_WEIGHT = 0.7     # Weight for magnetometer reading\n    \n    def __init__(self, io, drive, sensor, AngleSensor, proximity_sensor=None):\n        self.drive = drive\n        self.sensor = sensor\n        self.AngleSensor = AngleSensor\n        self.proximity_sensor = proximity_sensor  # Add proximity sensor\n    \n        # Deadend detection parameters\n        self.lost_line_time = 0\n        self.MAX_LOST_LINE_TIME = 1.0  # Maximum time to spend hunting for a lost line before treating as deadend\n        \n        t_intersection = 0.20\n        t_end = 0.35\n        t_side = 0.3\n        side_threshold = 0.30  # Increased from 0.05 to be more tolerant of wobbling\n\n        # Timers and states for detectors\n        self.tlast = time.time()\n\n        self.intersection_level = 0.0\n        self.intersection_state = False\n        self.t_intersection = t_intersection\n\n        self.end_level = 0.0\n        self.end_state = False\n        self.t_end = t_end\n\n        self.side_level = 0.0\n        self.side_state = \"center\"\n        self.t_side = t_side\n        self.side_threshold = side_threshold\n\n        # Turning Behavior\n        self.turn_level = 0.0\n        self.t_spin = 0.1\n        self.on_path = False\n\n    def reset_filters(self):\n        self.intersection_level = 0.0\n        self.intersection_state = False\n        self.end_level = 0.0\n        self.end_state = False\n        self.side_level = 0.0\n        self.side_state = \"center\"\n        self.lost_line_time = 0\n\n    def raw_side_estimate(self, reading):\n        if reading == [1, 0, 0]:\n            return 1.0\n        elif reading == [0, 0, 1]: \n            return -1.0\n        elif reading == [1, 1, 0]:\n            return 0.5\n        elif reading == [0, 1, 1]:\n            return -0.5\n        elif reading == [0, 1, 0] or reading == [1, 1, 1]:\n            return 0.0\n        else:\n            return 0.0\n        \n    def update_detectors(self, L, M, R):\n        tnow = time.time()\n        dt = tnow - self.tlast\n        self.tlast = tnow\n\n        # INTERSECTION DETECTOR\n        raw_intersection = 1.0 if (L, M, R) == (1, 1, 1) else 0.0\n        self.intersection_level += dt / self.t_intersection * (raw_intersection - self.intersection_level)\n        if self.intersection_level > self.THRESHOLD_HIGH:\n            self.intersection_state = True\n        elif self.intersection_level < self.THRESHOLD_LOW:\n            self.intersection_state = False\n\n        # END DETECTOR\n        if self.side_state == \"center\":\n            if (L,M,R) == (0,0,0):\n                raw_end = 1.0\n            else:\n                raw_end = 0.0\n        else:\n            raw_end = 0.0        \n        self.end_level += dt / self.t_end * (raw_end - self.end_level)\n        if self.end_level > 0.8:\n            self.end_state = True\n        elif self.end_level < self.THRESHOLD_LOW:\n            self.end_state = False\n\n        # SIDE ESTIMATOR\n        if (L, M, R) != (0, 0, 0):\n            # When on a line, update side state normally\n            reading = [L, M, R]\n            raw_side = self.raw_side_estimate(reading)\n            self.side_level += dt / self.t_side * (raw_side - self.side_level)\n            if self.side_level > self.side_threshold:\n                self.side_state = \"right\"\n            elif self.side_level < -self.side_threshold:\n                self.side_state = \"left\"\n            else:\n                self.side_state = \"center\"\n        elif self.end_level < 0.3:\n            # When line is lost but not yet confirmed as end, keep side state stable\n            # This gives end detector time to accumulate evidence\n            pass\n\n    def follow_line(self, block_threshold_cm=10, clear_threshold_cm=20):\n        \"\"\"\n        Follow the line, but stop if the forward proximity sensor detects an obstacle closer than block_threshold_cm.\n        Wait until the path is clear (distance > clear_threshold_cm) before resuming.\n        \"\"\"\n        self.lost_line_time = 0  # Reset timer when starting to follow line\n        waiting_for_clear = False\n\n        while True:\n            # --- Scan ahead for obstacles ---\n            blocked = False\n            if self.proximity_sensor is not None:\n                distances = self.proximity_sensor.read_all()\n                middle = distances[1]\n                if middle is not None:\n                    if not waiting_for_clear and middle < block_threshold_cm:\n                        print(f\"Obstacle detected ahead at {middle:.1f} cm! Stopping robot before collision.\")\n                        self.drive.stop()\n                        waiting_for_clear = True\n                        # Do not update detectors while stopped\n                        time.sleep(0.05)\n                        continue\n                    elif waiting_for_clear:\n                        if middle > clear_threshold_cm:\n                            print(f\"Path ahead is now clear at {middle:.1f} cm. Resuming line following.\")\n                            waiting_for_clear = False\n                        else:\n                            # Still blocked, keep waiting\n                            continue\n\n            if waiting_for_clear:\n                # If for some reason we get here, just wait\n                self.drive.stop()\n                time.sleep(0.05)\n                continue\n\n            # --- Normal line following logic ---\n            L, M, R = self.sensor.read()\n            self.update_detectors(L, M, R)\n\n            if self.intersection_state:\n                self.drive.stop()\n                print(\"Intersection detected!\")\n                self.reset_filters()\n                self.lost_line_time = 0\n                print(self.intersection_level)\n                time.sleep(0.05)  # Add back a small delay to ensure stable state transition\n                return \"intersection\"\n\n            elif self.end_state:\n                self.drive.stop()\n                print(\"End of street detected!\")\n                self.reset_filters()\n                self.lost_line_time = 0\n                return \"end\"\n\n            elif (L, M, R) == (0, 0, 0):\n                print(f\"Tape lost. The estimated side is: {self.side_state}\")\n                # Increment lost line timer\n                self.lost_line_time += 0.01  # Assumes 10ms loop timing\n                if self.lost_line_time > self.MAX_LOST_LINE_TIME:\n                    self.drive.stop()\n                    print(f\"Line lost for {self.lost_line_time:.1f} seconds - treating as deadend!\")\n                    self.reset_filters()\n                    self.lost_line_time = 0\n                    return \"end\"\n                # Attempt to find the line based on side state\n                if self.side_state == \"left\":\n                    self.drive.drive(\"spin_r\")\n                elif self.side_state == \"right\":\n                    self.drive.drive(\"spin_l\")\n                else:\n                    self.drive.drive(\"straight\")\n            else:\n                # We're on a line, reset lost line timer\n                self.lost_line_time = 0\n                feedback = {\n                    (0, 1, 0): \"straight\",\n                    (0, 1, 1): \"turn_r\",\n                    (0, 0, 1): \"hook_r\",\n                    (1, 1, 0): \"turn_l\",\n                    (1, 0, 0): \"hook_l\",\n                    (1, 1, 1): \"straight\",\n                }\n                action = feedback.get((L, M, R), \"straight\")\n                self.drive.drive(action)\n\n            time.sleep(0.01)\n\n    def pull_forward(self):\n        t0 = time.time()\n        self.reset_filters()  # Reset any previous detector values\n        self.tlast = time.time()\n        self.end_level = 0.0\n        self.end_state = False\n\n        while True:\n\n            tnow = time.time()\n            dt = tnow - self.tlast\n            self.tlast = tnow\n            \n            L,M,R = self.sensor.read()\n            if M == 1:\n                raw_end = 1.0\n            else:\n                raw_end = 0.0\n                   \n            self.end_level += dt / self.t_end * (raw_end - self.end_level)\n            if self.end_level > self.THRESHOLD_HIGH:\n                self.end_state = True\n            elif self.end_level < self.THRESHOLD_LOW:\n                self.end_state = False\n\n            tnow = time.time()\n            self.drive.drive(\"straight\")\n            if tnow >= t0 + self.PULL_FORWARD_DURATION:\n                break\n            time.sleep(0.01)\n        self.drive.stop()\n        print(self.end_level)\n        \n        result = self.end_level > self.PULL_FORWARD_THRESHOLD\n        \n        self.reset_filters()\n\n        return result\n\n    def predict_turn_time(self, target_angle):\n        \"\"\"\n        Calculate turn time using quadratic formula to solve:\n        target_angle = -14.88x\u00b2 + 162.92x - 40.47\n        \"\"\"\n        a = self.TURN_COEFF_A\n        b = self.TURN_COEFF_B\n        c = self.TURN_COEFF_C - target_angle\n        \n        # Quadratic formula: (-b \u00b1 sqrt(b\u00b2 - 4ac)) / (2a)\n        # Since a is negative and we want positive time, use the smaller root\n        discriminant = b*b - 4*a*c\n        if discriminant < 0:\n            print(f\"Warning: No real solution for angle {target_angle}\u00b0\")\n            return 1.0  # Default fallback time\n            \n        time = (-b - math.sqrt(discriminant)) / (2*a)\n        return max(0.0, time)\n\n    def predict_angle_from_time(self, time):\n        \"\"\"\n        Predict angle using quadratic model with scaling correction:\n        angle = (-14.88x\u00b2 + 162.92x - 40.47) * scale_factor\n        \n        The scale factor corrects for the systematic underestimation\n        of large angles, particularly around 360 degrees.\n        \"\"\"\n        base_angle = (self.TURN_COEFF_A * time**2 + \n                     self.TURN_COEFF_B * time + \n                     self.TURN_COEFF_C)\n        \n        # Apply scaling correction\n        # Scale more aggressively for larger angles\n        if base_angle > 180:\n            scale = self.TURN_SCALE_FACTOR\n        else:\n            # Linear interpolation of scale factor based on angle\n            scale = 1.0 + (base_angle / 180.0) * (self.TURN_SCALE_FACTOR - 1.0)\n            \n        return base_angle * scale\n\n    def turning_behavior(self, choice):\n        print(f\"Starting turning behavior: {choice}\")\n        \n        # Reset turn detector\n        self.turn_level = 0.0\n        self.tlast = time.time()\n        \n        # Track angle using magnetometer\n        t_start = time.time()\n        prev_angle = self.AngleSensor.read_angle()\n        cumulative_angle = 0.0\n        \n        # Two-phase approach\n        # Phase 1: Get off the current line\n        phase = 1\n        \n        # Start turning\n        if choice == \"left\":\n            self.drive.drive(\"spin_l\")\n        elif choice == \"right\":\n            self.drive.drive(\"spin_r\")\n            \n        while True:\n            curr_angle = self.AngleSensor.read_angle()\n            delta = curr_angle - prev_angle\n\n            if delta > 180:\n                delta -= 360\n            if delta < -180:\n                delta += 360\n\n            if choice == \"left\":\n                cumulative_angle += delta\n            else:\n                cumulative_angle -= delta\n            prev_angle = curr_angle\n            \n            # Read line sensor\n            L, M, R = self.sensor.read()\n            \n            # Determine if we're on a line\n            if phase == 1:\n                # Phase 1: Looking to get OFF the line\n                raw = 0.0 if M == 1 else 1.0  # Inverted logic to detect when OFF the line\n            else:\n                # Phase 2: Looking to get back ON a line\n                raw = 1.0 if M == 1 else 0.0\n                \n            # Update turn detector\n            tnow = time.time()\n            dt = tnow - self.tlast\n            self.tlast = tnow\n            self.turn_level += dt / self.t_spin * (raw - self.turn_level)\n            \n            # State transitions\n            if phase == 1 and self.turn_level > 0.63:\n                # Successfully off the line, transition to phase 2\n                phase = 2\n                # Reset detection level for new phase\n                self.turn_level = 0.0\n            elif phase == 2 and self.turn_level > 0.63:\n                # Found new line\n                break\n                \n        # Done turning\n        self.drive.stop()\n        \n        # Calculate time and time-based prediction before realignment\n        t_end = time.time()\n        elapsed = t_end - t_start\n        time_based_angle = self.predict_angle_from_time(elapsed)\n        if choice == \"right\":\n            time_based_angle = -time_based_angle\n            \n        # Realign to center of line\n        self.realign(choice)\n        \n        # Get final magnetometer reading after realignment\n        if choice == \"right\":\n            magnetometer_angle = -abs(cumulative_angle)\n        else:\n            magnetometer_angle = abs(cumulative_angle)\n            \n        # Calculate weighted average of the two measurements\n        weighted_angle = (self.TIME_WEIGHT * time_based_angle + \n                        self.ANGLE_WEIGHT * magnetometer_angle)\n        \n        # Round the average to nearest 45\u00b0 increment\n        num_increments = round(weighted_angle / 45.0)\n        final_angle = num_increments * 45.0\n        \n        # Data collection mode - print all measurements\n        print(\"\\nTurn Analysis:\")\n        print(f\"Elapsed Time: {elapsed:.3f}s\")\n        print(f\"Time-based prediction: {time_based_angle:.1f}\u00b0\")\n        print(f\"Magnetometer reading: {magnetometer_angle:.1f}\u00b0\")\n        print(f\"Weighted average: {weighted_angle:.1f}\u00b0\")\n        print(f\"Rounded to: {final_angle:.1f}\u00b0 ({num_increments} \u00d7 45\u00b0)\")\n            \n        # Return both the number of 45-degree steps and the weighted average angle\n        return num_increments, magnetometer_angle\n\n    def realign(self, choice):\n        if choice == \"left\":\n            self.drive.drive(\"spin_r\")\n        elif choice == \"right\":\n            self.drive.drive(\"spin_l\")\n        while True:\n            (L,M,R) = self.sensor.read()\n            if (L,M,R) == (0,1,0):\n                self.drive.stop()\n                break\n                    \n    def check_blockage(self, heading):\n        \"\"\"\n        Returns True if the forward-facing (middle) ultrasound sensor detects an obstacle closer than threshold_cm.\n        \"\"\"\n        if self.proximity_sensor is None:\n            return False  # If no sensor, assume not blocked\n        distances = self.proximity_sensor.read_all()\n        middle = distances[1]\n        if heading % 2 == 0:\n            if middle is not None and middle < 40:\n                print(f\"Blockage detected ahead! Distance: {middle:.1f} cm < 40 cm\")\n                return True\n            else:\n                print(f\"No blockage detected. Distance: {middle:.1f} cm >= 40 cm\")\n                return False\n        else:\n            if middle is not None and middle < 65:\n                print(f\"Blockage detected ahead! Distance: {middle:.1f} cm < 65 cm\")\n                return True\n            else:\n                print(f\"No blockage detected. Distance: {middle:.1f} cm >= 65 cm\")\n                return False\n\n\nif __name__ == \"__main__\":\n    io = pigpio.pi()\n    if not io.connected:\n        print(\"Could not connect to pigpio daemon.\")\n        exit()\n\n    try:\n        drive = DriveSystem(io)\n        sensor = LineSensor(io)\n        anglesensor = AngleSensor(io)\n        proximity_sensor = ProximitySensor(io)\n        behaviors = Behaviors(io, drive, sensor, anglesensor, proximity_sensor)\n\n        print(\"Simple Brain started.\")\n        \n        while True:\n            choice = input(\"Drive Straight, left, or right: \").lower()\n\n            if choice in (\"left\", \"right\"):\n                behaviors.turning_behavior(choice)\n\n            elif choice == \"straight\":\n                print(\"Following line\")\n                result = behaviors.follow_line()\n\n                if result == \"intersection\":\n                    print(\"Intersection reached.\")\n                    behaviors.pull_forward()\n\n                elif result == \"end\":\n                    print(\"Reached end of the street.\")\n\n                else:\n                    print(\"Unknown line-following result:\", result)\n\n            else:\n                print(\"Invalid input. Please enter 'straight', 'left', or 'right'.\")\n\n\n\n    except KeyboardInterrupt:\n        print(\"KeyboardInterrupt detected. Exiting...\")\n\n    except BaseException as ex:\n        print(\"Ending due to exception: %s\" % repr(ex))\n        traceback.print_exc()\n\n    finally:\n        drive.stop()\n        io.stop()\n        print(\"Robot stopped. Brain shutdown :3\")\n\n\n\n",
  "HerdingAndWallFollowingBehavior.py": "import time\nimport pigpio\nfrom DriveSystem import DriveSystem\nfrom proximitysensor import ProximitySensor\nimport threading\n\n\ndef herding_behavior(drive, prox):\n    last_trigger_time = time.time()\n    prox.trigger_all()\n    time.sleep(0.05)\n\n    while True:\n        now = time.time()\n        if now - last_trigger_time > 0.05:\n            prox.trigger_all()\n            last_trigger_time = now\n\n        d_left, d_mid, d_right = prox.read_all()\n\n        left_close = d_left < 20\n        mid_far = d_mid > 20\n        mid_mid =  10 <= d_mid <= 20\n        mid_close = d_mid < 10\n        right_close = d_right < 20\n\n        # 12 explicit cases\n        if not left_close and mid_far and not right_close:\n            # All clear, go straight forward\n            drive.drive(\"straight\")\n        elif left_close and mid_far and not right_close:\n            # Obstacle left, go forward and steer right\n            drive.drive(\"steer_r\")\n        elif not left_close and mid_far and right_close:\n            # Obstacle right, go forward and steer left\n            drive.drive(\"steer_l\")\n        elif left_close and mid_far and right_close:\n            # obstacles both sides, go forward\n            drive.drive(\"straight\")\n        elif not left_close and mid_mid and not right_close:\n            # all clear, but something ahead at medium distance, so stop\n            drive.stop()\n        elif left_close and mid_mid and not right_close:\n            # Obstacle left, medium ahead, veer right (or stop)\n            drive.drive(\"steer_r\")\n        elif not left_close and mid_mid and right_close:\n            # Obstacle right, medium ahead, veer left (or stop)\n            drive.drive(\"steer_l\")\n        elif left_close and mid_mid and right_close:\n            # Obstacles both sides, medium ahead, spin left (or stop)\n            drive.drive(\"spin_l\")\n        elif not left_close and mid_close and not right_close:\n            # All clear on sides, but close ahead, back up straight\n            drive.drive(\"straight\", reverse=True)\n        elif left_close and mid_close and not right_close:\n            # Obstacle left, close ahead, back up and steer right\n            drive.drive(\"steer_r\", reverse=True)\n        elif not left_close and mid_close and right_close:\n            # Obstacle right, close ahead, back up and steer left\n            drive.drive(\"steer_l\", reverse=True)\n        elif left_close and mid_close and right_close:\n            # Obstacles everywhere, back up \n            drive.drive(\"straight\", reverse=True)\n        else:\n            # Fallback safety\n            drive.stop()\n\n        time.sleep(0.05)\n            \n\nclass SharedMode:\n    def __init__(self):\n        self.mode = 0  # 0=stop, 1=discrete, 2=continuous, -1=quit\n        self.lock = threading.Lock()\n\ndef ui(shared):\n    while True:\n        cmd = input(\"Enter command (discrete/continuous/stop/quit): \").strip().lower()\n        with shared.lock:\n            if cmd == \"discrete\":\n                shared.mode = 1\n            elif cmd == \"continuous\":\n                shared.mode = 2\n            elif cmd == \"stop\":\n                shared.mode = 0\n            elif cmd == \"quit\":\n                shared.mode = -1\n                break\n            else:\n                print(\"Unknown command.\")\n\ndef wall_following_behavior(drive, prox, shared):\n    d0 = 30 # Desired distance from wall in cm\n    while True:\n        with shared.lock:\n            mode = shared.mode\n        if mode < 0:\n            print(\"Quitting wall following loop.\")\n            break\n        elif mode == 0:\n            drive.stop()\n            time.sleep(0.05)\n            continue\n        elif mode == 1:\n            d_left, d_mid, d_right = prox.read_all()\n            if d_left is None:\n                drive.stop()\n                print(\"No left sensor reading. Stopping.\")\n                continue\n            if d_mid is not None and d_mid < 20:\n                drive.stop()\n                print(\"Obstacle ahead! Stopping.\")\n                continue\n            if d_left < 20 or d_left > 40:\n                drive.stop()\n                print(\"Too far from wall bounds. Stopping.\")\n                break\n            error = d_left - d0\n            print(f\"Distance from wall: {d_left} cm, Error: {error} cm\")\n            if abs(error) <= 3:\n                drive.drive(\"straight\")\n            elif  3 < error <= 7:\n                drive.drive(\"veer_l\")\n            elif 7 < error <= 10:\n                drive.drive(\"steer_l\")\n            elif -10 <= error < -7: \n                drive.drive(\"steer_r\")\n            elif -7 < error < -3:\n                drive.drive(\"veer_r\")\n            else:\n                drive.stop()  # fallback safety\n            time.sleep(0.05)\n        elif mode == 2:\n            d_left, d_mid, d_right = prox.read_all()\n            if d_left is None:\n                drive.stop()\n                print(\"No left sensor reading. Stopping.\")\n                continue\n            if d_mid is not None and d_mid < 20:\n                drive.stop()\n                print(\"Obstacle ahead! Stopping.\")\n                continue\n            if d_left < 20 or d_left > 40:\n                drive.stop()\n                print(\"Too far from wall bounds. Stopping.\")\n                break\n\n            error = d_left - d0\n            pwm_L = 0.8035347173 - 0.01189577199 * error\n            pwm_R = 0.7717609744 + 0.008546060135 * error\n\n            # Clamp PWM values to [0, 1] for safety\n            pwm_L = max(0, min(1, pwm_L))\n            pwm_R = max(0, min(1, pwm_R))\n\n            drive.pwm(pwm_L, pwm_R)\n            print(f\"Continuous mode: error={error:.2f}, pwm_L={pwm_L:.3f}, pwm_R={pwm_R:.3f}\")\n            time.sleep(0.05)\n        else:\n            drive.stop()\n            time.sleep(0.05)\n\n\nif __name__ == \"__main__\":\n\n    io = pigpio.pi()\n    if not io.connected:\n        print(\"Failed to connect to pigpio daemon.\")\n        exit()\n\n    drive = DriveSystem(io)\n    prox = ProximitySensor(io)\n    shared = SharedMode()\n    ui_thread = threading.Thread(target=ui, args=(shared,), daemon=True)\n    ui_thread.start()\n    try:\n        wall_following_behavior(drive, prox, shared)\n    except KeyboardInterrupt:\n        print(\"Stopping...\")\n    finally:\n        drive.stop()\n        prox.shutdown()\n        io.stop()\n",
  "AngleSensor.py": "import time\nimport pigpio\nimport math\n\nclass AngleSensor:\n    def __init__(self,io):\n        self.io = io\n        self.io.set_mode(27,pigpio.OUTPUT)\n        self.io.set_mode(4,pigpio.OUTPUT)\n\n        self.io.set_mode(17,pigpio.INPUT)\n        self.io.set_mode(9,pigpio.INPUT)\n        self.io.set_mode(10,pigpio.INPUT)\n        self.io.set_mode(11,pigpio.INPUT)\n        self.io.set_mode(12,pigpio.INPUT)\n        self.io.set_mode(22,pigpio.INPUT)\n        self.io.set_mode(23,pigpio.INPUT)\n        self.io.set_mode(24,pigpio.INPUT)\n        self.io.set_mode(25,pigpio.INPUT)\n    \n    # readadc converts the 8 bit binary value from the ADC to a decimal value\n    def readadc(self,address):\n        pin_array = [9,10,11,12,22,23,24,25]\n        data_array = []\n\n        self.io.write(27,0)\n        self.io.write(4,address)\n        self.io.write(27,1)\n        self.io.write(27,0)\n        self.io.write(27,1)\n\n        while self.io.read(17) == 0:\n            pass\n            \n        # converts the 8 bit binary value to decimal\n        for i in range(len(pin_array)):\n            value = self.io.read(pin_array[i])\n            data_array.insert(0,value)\n    \n        reading = 0\n        for i in range(len(data_array)):\n            if (data_array[i] == 1):\n                reading += 2 ** (len(data_array) - (i+1))\n                    \n               \n        return reading\n        \n    # read_angle reads the angle of the sensor and converts it to degrees\n    def read_angle(self):\n        ad_0 = self.readadc(0)\n        ad_1 = self.readadc(1)\n\n        # scaled values are between -1 and 1\n        # scaled value based off of magnetometer \n        scaled_0 = 2 * (ad_0 - 106) / (214 - 106) - 1\n        scaled_1 = 2 * (ad_1 - 95) / (210 -95) - 1\n        \n        phi_rad = math.atan2(scaled_0,scaled_1)\n        \n        phi_degrees = 180/math.pi * phi_rad\n        \n        return phi_degrees\n\n\n        \nif __name__ == \"__main__\":\n    io = pigpio.pi()\n    print(\"start\")\n    if not io.connected:\n        print(\"Could not connect to pigpio daemon.\")\n        exit()\n\n    try:\n        magnetometer = AngleSensor(io)\n        while True:\n            print(magnetometer.read_angle())\n            #time.sleep(0.0)\n        \n    except KeyboardInterrupt:\n        print(\"Divan\")\n    \n    finally:\n        io.stop()\n        print(\"Readings stopped\")\n\n\n    \n\n\n\n\n\n        \n        \n        \n\n\n        \n",
  "Sense.py": "import pigpio\n\n\nclass IR:\n    \"\"\"\n    A low-level class to interface with a single digital IR sensor.\n    Uses pigpio to read high/low values from a GPIO pin.\n    \"\"\"\n    def __init__(self, io, pin):\n        \"\"\"\n        Initialize a single IR sensor.\n        Parameters:\n        - io (pigpio.pi): The pigpio interface for controlling GPIO pins\n        - pin (int): GPIO pin number the sensor is connected to\n        \"\"\"\n        self.io = io\n        self.pin = pin\n        self.io.set_mode(pin, pigpio.INPUT)\n\n    def read(self):\n        \"\"\"\n        Returns 1 if black tape is detected, and\n        0 if white floor is detected\n        \"\"\"\n        return self.io.read(self.pin)\n\n\nclass LineSensor:\n    \"\"\"\n    A mid-level class that combines three IR sensors into one logical unit.\n    It reads left, middle, and right IR sensors and returns a 3-value tuple.\n    \"\"\"\n    \n    def __init__(self, io):\n        \"\"\"\n        Initialize LineSensor with three IR sensors.\n\n        Parameters:\n        - io (pigpio.pi): pigpio interface object\n        - pin_left (int): GPIO pin for the left IR sensor\n        - pin_middle (int): GPIO pin for the middle IR sensor\n        - pin_right (int): GPIO pin for the right IR sensor\n        \"\"\"\n        pin_left   = 14\n        pin_middle = 15\n        pin_right  = 18\n        \n        self.left = IR(io, pin_left)\n        self.middle = IR(io, pin_middle)\n        self.right  = IR(io, pin_right)\n\n    def read(self):\n        \"\"\"\n        Returns a tuple (L, M, R) of 0s and 1s\n        \"\"\"\n        L = self.left.read()\n        M = self.middle.read()\n        R = self.right.read()\n        return (L, M, R)\n"
};